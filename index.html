<!doctype html>
<html>
<head>
<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>
<title>javaTool</title><link href='https://fonts.loli.net/css?family=Open+Sans:400italic,700italic,700,400&subset=latin,latin-ext' rel='stylesheet' type='text/css' /><style type='text/css'>html {overflow-x: initial !important;}:root { --bg-color:#ffffff; --text-color:#333333; --select-text-bg-color:#B5D6FC; --select-text-font-color:auto; --monospace:"Lucida Console",Consolas,"Courier",monospace; }
html { font-size: 14px; background-color: var(--bg-color); color: var(--text-color); font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; }
body { margin: 0px; padding: 0px; height: auto; bottom: 0px; top: 0px; left: 0px; right: 0px; font-size: 1rem; line-height: 1.42857; overflow-x: hidden; background: inherit; tab-size: 4; }
iframe { margin: auto; }
a.url { word-break: break-all; }
a:active, a:hover { outline: 0px; }
.in-text-selection, ::selection { text-shadow: none; background: var(--select-text-bg-color); color: var(--select-text-font-color); }
#write { margin: 0px auto; height: auto; width: inherit; word-break: normal; word-wrap: break-word; position: relative; white-space: normal; overflow-x: visible; padding-top: 40px; }
#write.first-line-indent p { text-indent: 2em; }
#write.first-line-indent li p, #write.first-line-indent p * { text-indent: 0px; }
#write.first-line-indent li { margin-left: 2em; }
.for-image #write { padding-left: 8px; padding-right: 8px; }
body.typora-export { padding-left: 30px; padding-right: 30px; }
.typora-export .footnote-line, .typora-export li, .typora-export p { white-space: pre-wrap; }
@media screen and (max-width: 500px) {
  body.typora-export { padding-left: 0px; padding-right: 0px; }
  #write { padding-left: 20px; padding-right: 20px; }
  .CodeMirror-sizer { margin-left: 0px !important; }
  .CodeMirror-gutters { display: none !important; }
}
#write li > figure:first-child { margin-top: -20px; }
#write ol, #write ul { position: relative; }
img { max-width: 100%; vertical-align: middle; }
button, input, select, textarea { color: inherit; font-style: inherit; font-variant: inherit; font-weight: inherit; font-stretch: inherit; font-size: inherit; line-height: inherit; font-family: inherit; }
input[type="checkbox"], input[type="radio"] { line-height: normal; padding: 0px; }
*, ::after, ::before { box-sizing: border-box; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p, #write pre { width: inherit; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p { position: relative; }
h1, h2, h3, h4, h5, h6 { break-after: avoid-page; break-inside: avoid; orphans: 2; }
p { orphans: 4; }
h1 { font-size: 2rem; }
h2 { font-size: 1.8rem; }
h3 { font-size: 1.6rem; }
h4 { font-size: 1.4rem; }
h5 { font-size: 1.2rem; }
h6 { font-size: 1rem; }
.md-math-block, .md-rawblock, h1, h2, h3, h4, h5, h6, p { margin-top: 1rem; margin-bottom: 1rem; }
.hidden { display: none; }
.md-blockmeta { color: rgb(204, 204, 204); font-weight: 700; font-style: italic; }
a { cursor: pointer; }
sup.md-footnote { padding: 2px 4px; background-color: rgba(238, 238, 238, 0.7); color: rgb(85, 85, 85); border-radius: 4px; cursor: pointer; }
sup.md-footnote a, sup.md-footnote a:hover { color: inherit; text-transform: inherit; text-decoration: inherit; }
#write input[type="checkbox"] { cursor: pointer; width: inherit; height: inherit; }
figure { overflow-x: auto; margin: 1.2em 0px; max-width: calc(100% + 16px); padding: 0px; }
figure > table { margin: 0px !important; }
tr { break-inside: avoid; break-after: auto; }
thead { display: table-header-group; }
table { border-collapse: collapse; border-spacing: 0px; width: 100%; overflow: auto; break-inside: auto; text-align: left; }
table.md-table td { min-width: 32px; }
.CodeMirror-gutters { border-right: 0px; background-color: inherit; }
.CodeMirror-linenumber { user-select: none; }
.CodeMirror { text-align: left; }
.CodeMirror-placeholder { opacity: 0.3; }
.CodeMirror pre { padding: 0px 4px; }
.CodeMirror-lines { padding: 0px; }
div.hr:focus { cursor: none; }
#write pre { white-space: pre-wrap; }
#write.fences-no-line-wrapping pre { white-space: pre; }
#write pre.ty-contain-cm { white-space: normal; }
.CodeMirror-gutters { margin-right: 4px; }
.md-fences { font-size: 0.9rem; display: block; break-inside: avoid; text-align: left; overflow: visible; white-space: pre; background: inherit; position: relative !important; }
.md-diagram-panel { width: 100%; margin-top: 10px; text-align: center; padding-top: 0px; padding-bottom: 8px; overflow-x: auto; }
#write .md-fences.mock-cm { white-space: pre-wrap; }
.md-fences.md-fences-with-lineno { padding-left: 0px; }
#write.fences-no-line-wrapping .md-fences.mock-cm { white-space: pre; overflow-x: auto; }
.md-fences.mock-cm.md-fences-with-lineno { padding-left: 8px; }
.CodeMirror-line, twitterwidget { break-inside: avoid; }
.footnotes { opacity: 0.8; font-size: 0.9rem; margin-top: 1em; margin-bottom: 1em; }
.footnotes + .footnotes { margin-top: 0px; }
.md-reset { margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: top; background: 0px 0px; text-decoration: none; text-shadow: none; float: none; position: static; width: auto; height: auto; white-space: nowrap; cursor: inherit; -webkit-tap-highlight-color: transparent; line-height: normal; font-weight: 400; text-align: left; box-sizing: content-box; direction: ltr; }
li div { padding-top: 0px; }
blockquote { margin: 1rem 0px; }
li .mathjax-block, li p { margin: 0.5rem 0px; }
li { margin: 0px; position: relative; }
blockquote > :last-child { margin-bottom: 0px; }
blockquote > :first-child, li > :first-child { margin-top: 0px; }
.footnotes-area { color: rgb(136, 136, 136); margin-top: 0.714rem; padding-bottom: 0.143rem; white-space: normal; }
#write .footnote-line { white-space: pre-wrap; }
@media print {
  body, html { border: 1px solid transparent; height: 99%; break-after: avoid; break-before: avoid; }
  #write { margin-top: 0px; padding-top: 0px; border-color: transparent !important; }
  .typora-export * { -webkit-print-color-adjust: exact; }
  html.blink-to-pdf { font-size: 13px; }
  .typora-export #write { padding-left: 32px; padding-right: 32px; padding-bottom: 0px; break-after: avoid; }
  .typora-export #write::after { height: 0px; }
  @page { margin: 20mm 0px; }
}
.footnote-line { margin-top: 0.714em; font-size: 0.7em; }
a img, img a { cursor: pointer; }
pre.md-meta-block { font-size: 0.8rem; min-height: 0.8rem; white-space: pre-wrap; background: rgb(204, 204, 204); display: block; overflow-x: hidden; }
p > .md-image:only-child:not(.md-img-error) img, p > img:only-child { display: block; margin: auto; }
p > .md-image:only-child { display: inline-block; width: 100%; }
#write .MathJax_Display { margin: 0.8em 0px 0px; }
.md-math-block { width: 100%; }
.md-math-block:not(:empty)::after { display: none; }
[contenteditable="true"]:active, [contenteditable="true"]:focus { outline: 0px; box-shadow: none; }
.md-task-list-item { position: relative; list-style-type: none; }
.task-list-item.md-task-list-item { padding-left: 0px; }
.md-task-list-item > input { position: absolute; top: 0px; left: 0px; margin-left: -1.2em; margin-top: calc(1em - 10px); border: none; }
.math { font-size: 1rem; }
.md-toc { min-height: 3.58rem; position: relative; font-size: 0.9rem; border-radius: 10px; }
.md-toc-content { position: relative; margin-left: 0px; }
.md-toc-content::after, .md-toc::after { display: none; }
.md-toc-item { display: block; color: rgb(65, 131, 196); }
.md-toc-item a { text-decoration: none; }
.md-toc-inner:hover { text-decoration: underline; }
.md-toc-inner { display: inline-block; cursor: pointer; }
.md-toc-h1 .md-toc-inner { margin-left: 0px; font-weight: 700; }
.md-toc-h2 .md-toc-inner { margin-left: 2em; }
.md-toc-h3 .md-toc-inner { margin-left: 4em; }
.md-toc-h4 .md-toc-inner { margin-left: 6em; }
.md-toc-h5 .md-toc-inner { margin-left: 8em; }
.md-toc-h6 .md-toc-inner { margin-left: 10em; }
@media screen and (max-width: 48em) {
  .md-toc-h3 .md-toc-inner { margin-left: 3.5em; }
  .md-toc-h4 .md-toc-inner { margin-left: 5em; }
  .md-toc-h5 .md-toc-inner { margin-left: 6.5em; }
  .md-toc-h6 .md-toc-inner { margin-left: 8em; }
}
a.md-toc-inner { font-size: inherit; font-style: inherit; font-weight: inherit; line-height: inherit; }
.footnote-line a:not(.reversefootnote) { color: inherit; }
.md-attr { display: none; }
.md-fn-count::after { content: "."; }
code, pre, samp, tt { font-family: var(--monospace); }
kbd { margin: 0px 0.1em; padding: 0.1em 0.6em; font-size: 0.8em; color: rgb(36, 39, 41); background: rgb(255, 255, 255); border: 1px solid rgb(173, 179, 185); border-radius: 3px; box-shadow: rgba(12, 13, 14, 0.2) 0px 1px 0px, rgb(255, 255, 255) 0px 0px 0px 2px inset; white-space: nowrap; vertical-align: middle; }
.md-comment { color: rgb(162, 127, 3); opacity: 0.8; font-family: var(--monospace); }
code { text-align: left; vertical-align: initial; }
a.md-print-anchor { white-space: pre !important; border-width: initial !important; border-style: none !important; border-color: initial !important; display: inline-block !important; position: absolute !important; width: 1px !important; right: 0px !important; outline: 0px !important; background: 0px 0px !important; text-decoration: initial !important; text-shadow: initial !important; }
.md-inline-math .MathJax_SVG .noError { display: none !important; }
.html-for-mac .inline-math-svg .MathJax_SVG { vertical-align: 0.2px; }
.md-math-block .MathJax_SVG_Display { text-align: center; margin: 0px; position: relative; text-indent: 0px; max-width: none; max-height: none; min-height: 0px; min-width: 100%; width: auto; overflow-y: hidden; display: block !important; }
.MathJax_SVG_Display, .md-inline-math .MathJax_SVG_Display { width: auto; margin: inherit; display: inline-block !important; }
.MathJax_SVG .MJX-monospace { font-family: var(--monospace); }
.MathJax_SVG .MJX-sans-serif { font-family: sans-serif; }
.MathJax_SVG { display: inline; font-style: normal; font-weight: 400; line-height: normal; zoom: 90%; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; }
.MathJax_SVG * { transition: none; }
.MathJax_SVG_Display svg { vertical-align: middle !important; margin-bottom: 0px !important; }
.os-windows.monocolor-emoji .md-emoji { font-family: "Segoe UI Symbol", sans-serif; }
.md-diagram-panel > svg { max-width: 100%; }
[lang="mermaid"] svg, [lang="flow"] svg { max-width: 100%; }
[lang="mermaid"] .node text { font-size: 1rem; }
table tr th { border-bottom: 0px; }
video { max-width: 100%; display: block; margin: 0px auto; }
iframe { max-width: 100%; width: 100%; border: none; }
.highlight td, .highlight tr { border: 0px; }


.CodeMirror { height: auto; }
.CodeMirror.cm-s-inner { background: inherit; }
.CodeMirror-scroll { overflow-y: hidden; overflow-x: auto; z-index: 3; }
.CodeMirror-gutter-filler, .CodeMirror-scrollbar-filler { background-color: rgb(255, 255, 255); }
.CodeMirror-gutters { border-right: 1px solid rgb(221, 221, 221); background: inherit; white-space: nowrap; }
.CodeMirror-linenumber { padding: 0px 3px 0px 5px; text-align: right; color: rgb(153, 153, 153); }
.cm-s-inner .cm-keyword { color: rgb(119, 0, 136); }
.cm-s-inner .cm-atom, .cm-s-inner.cm-atom { color: rgb(34, 17, 153); }
.cm-s-inner .cm-number { color: rgb(17, 102, 68); }
.cm-s-inner .cm-def { color: rgb(0, 0, 255); }
.cm-s-inner .cm-variable { color: rgb(0, 0, 0); }
.cm-s-inner .cm-variable-2 { color: rgb(0, 85, 170); }
.cm-s-inner .cm-variable-3 { color: rgb(0, 136, 85); }
.cm-s-inner .cm-string { color: rgb(170, 17, 17); }
.cm-s-inner .cm-property { color: rgb(0, 0, 0); }
.cm-s-inner .cm-operator { color: rgb(152, 26, 26); }
.cm-s-inner .cm-comment, .cm-s-inner.cm-comment { color: rgb(170, 85, 0); }
.cm-s-inner .cm-string-2 { color: rgb(255, 85, 0); }
.cm-s-inner .cm-meta { color: rgb(85, 85, 85); }
.cm-s-inner .cm-qualifier { color: rgb(85, 85, 85); }
.cm-s-inner .cm-builtin { color: rgb(51, 0, 170); }
.cm-s-inner .cm-bracket { color: rgb(153, 153, 119); }
.cm-s-inner .cm-tag { color: rgb(17, 119, 0); }
.cm-s-inner .cm-attribute { color: rgb(0, 0, 204); }
.cm-s-inner .cm-header, .cm-s-inner.cm-header { color: rgb(0, 0, 255); }
.cm-s-inner .cm-quote, .cm-s-inner.cm-quote { color: rgb(0, 153, 0); }
.cm-s-inner .cm-hr, .cm-s-inner.cm-hr { color: rgb(153, 153, 153); }
.cm-s-inner .cm-link, .cm-s-inner.cm-link { color: rgb(0, 0, 204); }
.cm-negative { color: rgb(221, 68, 68); }
.cm-positive { color: rgb(34, 153, 34); }
.cm-header, .cm-strong { font-weight: 700; }
.cm-del { text-decoration: line-through; }
.cm-em { font-style: italic; }
.cm-link { text-decoration: underline; }
.cm-error { color: red; }
.cm-invalidchar { color: red; }
.cm-constant { color: rgb(38, 139, 210); }
.cm-defined { color: rgb(181, 137, 0); }
div.CodeMirror span.CodeMirror-matchingbracket { color: rgb(0, 255, 0); }
div.CodeMirror span.CodeMirror-nonmatchingbracket { color: rgb(255, 34, 34); }
.cm-s-inner .CodeMirror-activeline-background { background: inherit; }
.CodeMirror { position: relative; overflow: hidden; }
.CodeMirror-scroll { height: 100%; outline: 0px; position: relative; box-sizing: content-box; background: inherit; }
.CodeMirror-sizer { position: relative; }
.CodeMirror-gutter-filler, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-vscrollbar { position: absolute; z-index: 6; display: none; }
.CodeMirror-vscrollbar { right: 0px; top: 0px; overflow: hidden; }
.CodeMirror-hscrollbar { bottom: 0px; left: 0px; overflow: hidden; }
.CodeMirror-scrollbar-filler { right: 0px; bottom: 0px; }
.CodeMirror-gutter-filler { left: 0px; bottom: 0px; }
.CodeMirror-gutters { position: absolute; left: 0px; top: 0px; padding-bottom: 30px; z-index: 3; }
.CodeMirror-gutter { white-space: normal; height: 100%; box-sizing: content-box; padding-bottom: 30px; margin-bottom: -32px; display: inline-block; }
.CodeMirror-gutter-wrapper { position: absolute; z-index: 4; background: 0px 0px !important; border: none !important; }
.CodeMirror-gutter-background { position: absolute; top: 0px; bottom: 0px; z-index: 4; }
.CodeMirror-gutter-elt { position: absolute; cursor: default; z-index: 4; }
.CodeMirror-lines { cursor: text; }
.CodeMirror pre { border-radius: 0px; border-width: 0px; background: 0px 0px; font-family: inherit; font-size: inherit; margin: 0px; white-space: pre; word-wrap: normal; color: inherit; z-index: 2; position: relative; overflow: visible; }
.CodeMirror-wrap pre { word-wrap: break-word; white-space: pre-wrap; word-break: normal; }
.CodeMirror-code pre { border-right: 30px solid transparent; width: fit-content; }
.CodeMirror-wrap .CodeMirror-code pre { border-right: none; width: auto; }
.CodeMirror-linebackground { position: absolute; left: 0px; right: 0px; top: 0px; bottom: 0px; z-index: 0; }
.CodeMirror-linewidget { position: relative; z-index: 2; overflow: auto; }
.CodeMirror-wrap .CodeMirror-scroll { overflow-x: hidden; }
.CodeMirror-measure { position: absolute; width: 100%; height: 0px; overflow: hidden; visibility: hidden; }
.CodeMirror-measure pre { position: static; }
.CodeMirror div.CodeMirror-cursor { position: absolute; visibility: hidden; border-right: none; width: 0px; }
.CodeMirror div.CodeMirror-cursor { visibility: hidden; }
.CodeMirror-focused div.CodeMirror-cursor { visibility: inherit; }
.cm-searching { background: rgba(255, 255, 0, 0.4); }
@media print {
  .CodeMirror div.CodeMirror-cursor { visibility: hidden; }
}


:root { --side-bar-bg-color: #fafafa; --control-text-color: #777; }
html { font-size: 16px; -webkit-font-smoothing: antialiased; }
body { font-family: "Open Sans", "Clear Sans", "Helvetica Neue", Helvetica, Arial, "Segoe UI Emoji", sans-serif; color: rgb(0, 64, 80); line-height: 1.6; }
#write { max-width: 860px; margin: 0px auto; padding: 30px 30px 100px; }
@media only screen and (min-width: 1400px) {
  #write { max-width: 1024px; }
}
@media only screen and (min-width: 1800px) {
  #write { max-width: 1200px; }
}
#write > ul:first-child, #write > ol:first-child { margin-top: 30px; }
a { color: rgb(65, 131, 196); }
h1, h2, h3, h4, h5, h6 { position: relative; margin-top: 1rem; margin-bottom: 1rem; font-weight: bold; line-height: 1.4; cursor: text; }
h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor { text-decoration: none; }
h1 tt, h1 code { font-size: inherit; }
h2 tt, h2 code { font-size: inherit; }
h3 tt, h3 code { font-size: inherit; }
h4 tt, h4 code { font-size: inherit; }
h5 tt, h5 code { font-size: inherit; }
h6 tt, h6 code { font-size: inherit; }
h1 { font-size: 2.25em; line-height: 1.2; border-bottom: 1px solid rgb(238, 238, 238); }
h2 { font-size: 1.75em; line-height: 1.225; border-bottom: 1px solid rgb(238, 238, 238); }
h3 { font-size: 1.5em; line-height: 1.43; }
h4 { font-size: 1.25em; }
h5 { font-size: 1em; }
h6 { font-size: 1em; color: rgb(119, 119, 119); }
p, blockquote, ul, ol, dl, table { margin: 0.8em 0px; }
li > ol, li > ul { margin: 0px; }
hr { height: 2px; padding: 0px; margin: 16px 0px; background-color: rgb(231, 231, 231); border: 0px none; overflow: hidden; box-sizing: content-box; }
li p.first { display: inline-block; }
ul, ol { padding-left: 30px; }
ul:first-child, ol:first-child { margin-top: 0px; }
ul:last-child, ol:last-child { margin-bottom: 0px; }
blockquote { border-left: 5px solid rgb(66, 185, 131); padding: 8px 15px; color: rgb(33, 93, 66); background-color: rgb(243, 245, 247); }
blockquote blockquote { padding-right: 0px; }
table { padding: 0px; word-break: initial; }
table tr { border: 1px solid rgb(223, 226, 229); margin: 0px; padding: 0px; }
table tr:nth-child(2n), thead { background-color: rgb(248, 248, 248); }
table th { font-weight: bold; border-width: 1px 1px 0px; border-top-style: solid; border-right-style: solid; border-left-style: solid; border-top-color: rgb(223, 226, 229); border-right-color: rgb(223, 226, 229); border-left-color: rgb(223, 226, 229); border-image: initial; border-bottom-style: initial; border-bottom-color: initial; margin: 0px; padding: 6px 13px; }
table td { border: 1px solid rgb(223, 226, 229); margin: 0px; padding: 6px 13px; }
table th:first-child, table td:first-child { margin-top: 0px; }
table th:last-child, table td:last-child { margin-bottom: 0px; }
.CodeMirror-lines { padding-left: 4px; }
.code-tooltip { box-shadow: rgba(0, 28, 36, 0.3) 0px 1px 1px 0px; border-top: 1px solid rgb(238, 242, 242); }
.md-fences, code, tt { border: 1px solid rgb(231, 234, 237); background-color: rgb(248, 248, 248); border-radius: 3px; padding: 2px 4px 0px; font-size: 0.9em; }
code { background-color: rgb(243, 244, 244); padding: 2px; color: rgb(209, 37, 115); }
.md-fences { margin-bottom: 15px; margin-top: 15px; padding-top: 8px; padding-bottom: 6px; }
.md-task-list-item > input { margin-left: -1.3em; }
@media print {
  html { font-size: 13px; }
  table, pre { break-inside: avoid; }
  pre { word-wrap: break-word; }
}
.md-fences { background-color: rgb(248, 248, 248); }
#write pre.md-meta-block { padding: 1rem; font-size: 85%; line-height: 1.45; background-color: rgb(247, 247, 247); border: 0px; border-radius: 3px; color: rgb(119, 119, 119); margin-top: 0px !important; }
.mathjax-block > .code-tooltip { bottom: 0.375rem; }
.md-mathjax-midline { background: rgb(250, 250, 250); }
#write > h3.md-focus::before { left: -1.5625rem; top: 0.375rem; }
#write > h4.md-focus::before { left: -1.5625rem; top: 0.285714rem; }
#write > h5.md-focus::before { left: -1.5625rem; top: 0.285714rem; }
#write > h6.md-focus::before { left: -1.5625rem; top: 0.285714rem; }
.md-image > .md-meta { border-radius: 3px; padding: 2px 0px 0px 4px; font-size: 0.9em; color: inherit; }
.md-tag { color: rgb(167, 167, 167); opacity: 1; }
.md-toc { margin-top: 20px; padding-bottom: 20px; }
.sidebar-tabs { border-bottom: none; }
#typora-quick-open { border: 1px solid rgb(221, 221, 221); background-color: rgb(248, 248, 248); }
#typora-quick-open-item { background-color: rgb(250, 250, 250); border-color: rgb(254, 254, 254) rgb(229, 229, 229) rgb(229, 229, 229) rgb(238, 238, 238); border-style: solid; border-width: 1px; }
.on-focus-mode blockquote { border-left-color: rgba(85, 85, 85, 0.12); }
header, .context-menu, .megamenu-content, footer { font-family: "Segoe UI", Arial, sans-serif; }
.file-node-content:hover .file-node-icon, .file-node-content:hover .file-node-open-state { visibility: visible; }
.mac-seamless-mode #typora-sidebar { background-color: var(--side-bar-bg-color); }
.md-lang { color: rgb(180, 101, 77); }
#md-notification .btn { border: 0px; }
.dropdown-menu .divider { border-color: rgb(229, 229, 229); opacity: 0.4; }
.ty-preferences .window-content { background-color: rgb(250, 250, 250); }
.ty-preferences .nav-group-item.active { color: white; background: rgb(153, 153, 153); }
.menu-item-container a.menu-style-btn { background-color: rgb(245, 248, 250); background-image: linear-gradient(rgba(255, 255, 255, 0.8), rgba(255, 255, 255, 0)); }
#write mark { background: transparent; color: rgb(216, 105, 105); font-weight: bold; }
p .md-image:only-child { width: auto; text-align: left; }


.cm-s-inner { background-color: rgb(38, 50, 56); color: rgb(233, 237, 237); }
.cm-s-inner .CodeMirror-gutters { background: rgb(38, 50, 56); color: rgb(83, 127, 126); border: none; }
.cm-s-inner .CodeMirror-guttermarker, .cm-s-inner .CodeMirror-guttermarker-subtle, .cm-s-inner .CodeMirror-linenumber { color: rgb(83, 127, 126); }
.cm-s-inner .CodeMirror-cursor { border-left: 1px solid rgb(248, 248, 240); }
.cm-s-inner div.CodeMirror-selected { background: rgba(255, 255, 255, 0.15); }
.cm-s-inner.CodeMirror-focused div.CodeMirror-selected { background: rgba(255, 255, 255, 0.1); }
.cm-s-inner .CodeMirror-line::selection, .cm-s-inner .CodeMirror-line > span::selection, .cm-s-inner .CodeMirror-line > span > span::selection { background: rgba(255, 255, 255, 0.1); }
.cm-s-inner .CodeMirror-activeline-background { background: rgba(0, 0, 0, 0); }
.cm-s-inner .cm-keyword { color: rgb(199, 146, 234); }
.cm-s-inner .cm-operator { color: rgb(233, 237, 237); }
.cm-s-inner .cm-variable-2 { color: rgb(128, 203, 196); }
.cm-s-inner .cm-variable-3 { color: rgb(158, 255, 255); }
.cm-s-inner .cm-builtin { color: rgb(222, 203, 107); }
.cm-s-inner .cm-atom { color: rgb(247, 118, 105); }
.cm-s-inner .cm-number { color: rgb(247, 118, 105); }
.cm-s-inner .cm-def { color: rgb(233, 237, 237); }
.cm-s-inner .cm-string { color: rgb(195, 232, 141); }
.cm-s-inner .cm-string-2 { color: rgb(128, 203, 196); }
.cm-s-inner .cm-comment { color: rgb(84, 110, 122); }
.cm-s-inner .cm-variable { color: rgb(158, 255, 255); }
.cm-s-inner .cm-tag { color: rgb(128, 203, 196); }
.cm-s-inner .cm-meta { color: rgb(128, 203, 196); }
.cm-s-inner .cm-attribute { color: rgb(255, 203, 107); }
.cm-s-inner .cm-property { color: rgb(128, 203, 174); }
.cm-s-inner .cm-qualifier { color: rgb(222, 203, 107); }
.cm-s-inner .cm-variable-3 { color: rgb(222, 203, 107); }
.cm-s-inner .cm-tag { color: rgb(255, 83, 112); }
.cm-s-inner .cm-error { color: rgb(255, 255, 255); background-color: rgb(236, 95, 103); }
.cm-s-inner .CodeMirror-matchingbracket { text-decoration: underline; color: white !important; }
.md-fences { background-color: rgb(38, 50, 56); color: rgb(233, 237, 237); border: none; }
.md-fences .code-tooltip { background-color: rgb(38, 50, 56); }




</style>
</head>
<body class='typora-export os-windows' >
<div  id='write'  class = 'is-node first-line-indent'><blockquote><p>Author：Zhry</p><p>Email：<a href='mailto:2553179694@qq.com' target='_blank' class='url'>2553179694@qq.com</a></p><p>Version：1.0.3</p></blockquote><h1><a name='header-n5' class='md-header-anchor '></a>目录</h1><div class='md-toc' mdtype='toc'><p class="md-toc-content"><span class="md-toc-item md-toc-h1" data-ref="n5"><a class="md-toc-inner" href="#header-n5">目录</a></span><span class="md-toc-item md-toc-h1" data-ref="n8"><a class="md-toc-inner" href="#header-n8">一、Git</a></span><span class="md-toc-item md-toc-h2" data-ref="n9"><a class="md-toc-inner" href="#header-n9">1. Git概述</a></span><span class="md-toc-item md-toc-h3" data-ref="n10"><a class="md-toc-inner" href="#header-n10">1.1 版本系统</a></span><span class="md-toc-item md-toc-h3" data-ref="n22"><a class="md-toc-inner" href="#header-n22">1.2 工作流程</a></span><span class="md-toc-item md-toc-h3" data-ref="n29"><a class="md-toc-inner" href="#header-n29">1.3 Git安装</a></span><span class="md-toc-item md-toc-h3" data-ref="n32"><a class="md-toc-inner" href="#header-n32">1.4 代码托管</a></span><span class="md-toc-item md-toc-h2" data-ref="n40"><a class="md-toc-inner" href="#header-n40">2. 环境配置</a></span><span class="md-toc-item md-toc-h2" data-ref="n58"><a class="md-toc-inner" href="#header-n58">3. 本地仓库</a></span><span class="md-toc-item md-toc-h3" data-ref="n59"><a class="md-toc-inner" href="#header-n59">3.1 获取仓库</a></span><span class="md-toc-item md-toc-h3" data-ref="n100"><a class="md-toc-inner" href="#header-n100">3.2 工作过程</a></span><span class="md-toc-item md-toc-h3" data-ref="n105"><a class="md-toc-inner" href="#header-n105">3.3 文件操作</a></span><span class="md-toc-item md-toc-h4" data-ref="n106"><a class="md-toc-inner" href="#header-n106">3.3.1 常用命令</a></span><span class="md-toc-item md-toc-h4" data-ref="n150"><a class="md-toc-inner" href="#header-n150">3.3.2 文件状态</a></span><span class="md-toc-item md-toc-h4" data-ref="n176"><a class="md-toc-inner" href="#header-n176">3.3.3 文件忽略</a></span><span class="md-toc-item md-toc-h2" data-ref="n183"><a class="md-toc-inner" href="#header-n183">4. 远程仓库</a></span><span class="md-toc-item md-toc-h3" data-ref="n184"><a class="md-toc-inner" href="#header-n184">4.1 工作流程</a></span><span class="md-toc-item md-toc-h3" data-ref="n193"><a class="md-toc-inner" href="#header-n193">4.2 查看仓库</a></span><span class="md-toc-item md-toc-h3" data-ref="n198"><a class="md-toc-inner" href="#header-n198">4.3 添加仓库</a></span><span class="md-toc-item md-toc-h3" data-ref="n201"><a class="md-toc-inner" href="#header-n201">4.4 克隆仓库</a></span><span class="md-toc-item md-toc-h3" data-ref="n205"><a class="md-toc-inner" href="#header-n205">4.5 删除仓库</a></span><span class="md-toc-item md-toc-h3" data-ref="n208"><a class="md-toc-inner" href="#header-n208">4.6 拉取仓库</a></span><span class="md-toc-item md-toc-h3" data-ref="n213"><a class="md-toc-inner" href="#header-n213">4.7 推送仓库</a></span><span class="md-toc-item md-toc-h2" data-ref="n219"><a class="md-toc-inner" href="#header-n219">5. 版本管理</a></span><span class="md-toc-item md-toc-h2" data-ref="n226"><a class="md-toc-inner" href="#header-n226">6. 分支管理</a></span><span class="md-toc-item md-toc-h3" data-ref="n227"><a class="md-toc-inner" href="#header-n227">6.1 查看分支</a></span><span class="md-toc-item md-toc-h3" data-ref="n232"><a class="md-toc-inner" href="#header-n232">6.2 创建分支</a></span><span class="md-toc-item md-toc-h3" data-ref="n236"><a class="md-toc-inner" href="#header-n236">6.3 推送分支 </a></span><span class="md-toc-item md-toc-h3" data-ref="n239"><a class="md-toc-inner" href="#header-n239">6.4 切换分支</a></span><span class="md-toc-item md-toc-h3" data-ref="n242"><a class="md-toc-inner" href="#header-n242">6.5 合并分支</a></span><span class="md-toc-item md-toc-h3" data-ref="n247"><a class="md-toc-inner" href="#header-n247">6.6 删除分支</a></span><span class="md-toc-item md-toc-h2" data-ref="n254"><a class="md-toc-inner" href="#header-n254">7. 标签管理</a></span><span class="md-toc-item md-toc-h3" data-ref="n255"><a class="md-toc-inner" href="#header-n255">7.1 查看标签</a></span><span class="md-toc-item md-toc-h3" data-ref="n260"><a class="md-toc-inner" href="#header-n260">7.2 新建标签</a></span><span class="md-toc-item md-toc-h3" data-ref="n263"><a class="md-toc-inner" href="#header-n263">7.3 推送标签</a></span><span class="md-toc-item md-toc-h3" data-ref="n267"><a class="md-toc-inner" href="#header-n267">7.4 切换标签</a></span><span class="md-toc-item md-toc-h3" data-ref="n270"><a class="md-toc-inner" href="#header-n270">7.5 删除标签</a></span><span class="md-toc-item md-toc-h2" data-ref="n276"><a class="md-toc-inner" href="#header-n276">8. IDEA操作</a></span><span class="md-toc-item md-toc-h3" data-ref="n277"><a class="md-toc-inner" href="#header-n277">8.1 环境配置</a></span><span class="md-toc-item md-toc-h3" data-ref="n281"><a class="md-toc-inner" href="#header-n281">8.2 创建仓库</a></span><span class="md-toc-item md-toc-h3" data-ref="n287"><a class="md-toc-inner" href="#header-n287">8.3 文件操作</a></span><span class="md-toc-item md-toc-h3" data-ref="n290"><a class="md-toc-inner" href="#header-n290">8.4 版本管理</a></span><span class="md-toc-item md-toc-h3" data-ref="n300"><a class="md-toc-inner" href="#header-n300">8.5 分支管理</a></span><span class="md-toc-item md-toc-h3" data-ref="n313"><a class="md-toc-inner" href="#header-n313">8.6 推送仓库</a></span><span class="md-toc-item md-toc-h3" data-ref="n322"><a class="md-toc-inner" href="#header-n322">8.7 克隆仓库</a></span><span class="md-toc-item md-toc-h1" data-ref="n331"><a class="md-toc-inner" href="#header-n331">二、Linux</a></span><span class="md-toc-item md-toc-h2" data-ref="n332"><a class="md-toc-inner" href="#header-n332">1. 操作系统</a></span><span class="md-toc-item md-toc-h2" data-ref="n339"><a class="md-toc-inner" href="#header-n339">2. Linux系统</a></span><span class="md-toc-item md-toc-h3" data-ref="n340"><a class="md-toc-inner" href="#header-n340">2.1 系统介绍</a></span><span class="md-toc-item md-toc-h3" data-ref="n347"><a class="md-toc-inner" href="#header-n347">2.2 文件系统</a></span><span class="md-toc-item md-toc-h2" data-ref="n354"><a class="md-toc-inner" href="#header-n354">3. 远程连接</a></span><span class="md-toc-item md-toc-h3" data-ref="n355"><a class="md-toc-inner" href="#header-n355">3.1 设置IP</a></span><span class="md-toc-item md-toc-h4" data-ref="n356"><a class="md-toc-inner" href="#header-n356">3.1.1 NAT</a></span><span class="md-toc-item md-toc-h4" data-ref="n361"><a class="md-toc-inner" href="#header-n361">3.1.2 静态IP</a></span><span class="md-toc-item md-toc-h3" data-ref="n388"><a class="md-toc-inner" href="#header-n388">3.2 远程登陆</a></span><span class="md-toc-item md-toc-h2" data-ref="n398"><a class="md-toc-inner" href="#header-n398">4. 用户管理</a></span><span class="md-toc-item md-toc-h3" data-ref="n409"><a class="md-toc-inner" href="#header-n409">4.1 用户管理</a></span><span class="md-toc-item md-toc-h4" data-ref="n410"><a class="md-toc-inner" href="#header-n410">4.1.1 当前用户</a></span><span class="md-toc-item md-toc-h4" data-ref="n418"><a class="md-toc-inner" href="#header-n418">4.1.2 切换用户</a></span><span class="md-toc-item md-toc-h4" data-ref="n423"><a class="md-toc-inner" href="#header-n423">4.1.3 用户添加</a></span><span class="md-toc-item md-toc-h4" data-ref="n446"><a class="md-toc-inner" href="#header-n446">4.1.4 用户密码</a></span><span class="md-toc-item md-toc-h4" data-ref="n463"><a class="md-toc-inner" href="#header-n463">4.1.5 用户权限</a></span><span class="md-toc-item md-toc-h4" data-ref="n477"><a class="md-toc-inner" href="#header-n477">4.1.6 用户删除</a></span><span class="md-toc-item md-toc-h3" data-ref="n492"><a class="md-toc-inner" href="#header-n492">4.2 用户组管理</a></span><span class="md-toc-item md-toc-h4" data-ref="n493"><a class="md-toc-inner" href="#header-n493">4.2.1 组管理</a></span><span class="md-toc-item md-toc-h4" data-ref="n496"><a class="md-toc-inner" href="#header-n496">4.2.2 添加用户组</a></span><span class="md-toc-item md-toc-h4" data-ref="n506"><a class="md-toc-inner" href="#header-n506">4.2.3 修改用户组</a></span><span class="md-toc-item md-toc-h4" data-ref="n518"><a class="md-toc-inner" href="#header-n518">4.2.4 删除用户组</a></span><span class="md-toc-item md-toc-h4" data-ref="n530"><a class="md-toc-inner" href="#header-n530">4.2.5 用户所属组</a></span><span class="md-toc-item md-toc-h4" data-ref="n542"><a class="md-toc-inner" href="#header-n542">4.2.6 gpasswd</a></span><span class="md-toc-item md-toc-h2" data-ref="n556"><a class="md-toc-inner" href="#header-n556">5. 系统管理</a></span><span class="md-toc-item md-toc-h3" data-ref="n557"><a class="md-toc-inner" href="#header-n557">5.1 man</a></span><span class="md-toc-item md-toc-h3" data-ref="n564"><a class="md-toc-inner" href="#header-n564">5.2 date</a></span><span class="md-toc-item md-toc-h3" data-ref="n582"><a class="md-toc-inner" href="#header-n582">5.3 id</a></span><span class="md-toc-item md-toc-h3" data-ref="n601"><a class="md-toc-inner" href="#header-n601">5.4 sudo</a></span><span class="md-toc-item md-toc-h3" data-ref="n616"><a class="md-toc-inner" href="#header-n616">5.5 top</a></span><span class="md-toc-item md-toc-h3" data-ref="n660"><a class="md-toc-inner" href="#header-n660">5.6 ps</a></span><span class="md-toc-item md-toc-h3" data-ref="n695"><a class="md-toc-inner" href="#header-n695">5.7 kill</a></span><span class="md-toc-item md-toc-h3" data-ref="n719"><a class="md-toc-inner" href="#header-n719">5.8 shutdown</a></span><span class="md-toc-item md-toc-h3" data-ref="n750"><a class="md-toc-inner" href="#header-n750">5.9 reboot</a></span><span class="md-toc-item md-toc-h3" data-ref="n767"><a class="md-toc-inner" href="#header-n767">5.10 who</a></span><span class="md-toc-item md-toc-h3" data-ref="n790"><a class="md-toc-inner" href="#header-n790">5.11 systemctl</a></span><span class="md-toc-item md-toc-h3" data-ref="n824"><a class="md-toc-inner" href="#header-n824">5.12 timedatectl</a></span><span class="md-toc-item md-toc-h3" data-ref="n837"><a class="md-toc-inner" href="#header-n837">5.13 clear</a></span><span class="md-toc-item md-toc-h3" data-ref="n843"><a class="md-toc-inner" href="#header-n843">5.14 exit</a></span><span class="md-toc-item md-toc-h2" data-ref="n865"><a class="md-toc-inner" href="#header-n865">6. 文件管理</a></span><span class="md-toc-item md-toc-h3" data-ref="n866"><a class="md-toc-inner" href="#header-n866">6.1 常用命令</a></span><span class="md-toc-item md-toc-h4" data-ref="n867"><a class="md-toc-inner" href="#header-n867">6.1.1 ls</a></span><span class="md-toc-item md-toc-h4" data-ref="n880"><a class="md-toc-inner" href="#header-n880">6.1.2 pwd</a></span><span class="md-toc-item md-toc-h4" data-ref="n889"><a class="md-toc-inner" href="#header-n889">6.1.3 cd</a></span><span class="md-toc-item md-toc-h4" data-ref="n911"><a class="md-toc-inner" href="#header-n911">6.1.4 mkdir</a></span><span class="md-toc-item md-toc-h4" data-ref="n919"><a class="md-toc-inner" href="#header-n919">6.1.5 rmdir</a></span><span class="md-toc-item md-toc-h4" data-ref="n927"><a class="md-toc-inner" href="#header-n927">6.1.6 cp</a></span><span class="md-toc-item md-toc-h4" data-ref="n947"><a class="md-toc-inner" href="#header-n947">6.1.7 rm</a></span><span class="md-toc-item md-toc-h4" data-ref="n959"><a class="md-toc-inner" href="#header-n959">6.1.8 mv</a></span><span class="md-toc-item md-toc-h3" data-ref="n986"><a class="md-toc-inner" href="#header-n986">6.2 文件属性</a></span><span class="md-toc-item md-toc-h4" data-ref="n987"><a class="md-toc-inner" href="#header-n987">6.2.1 基本属性</a></span><span class="md-toc-item md-toc-h4" data-ref="n1017"><a class="md-toc-inner" href="#header-n1017">6.2.2 文件信息</a></span><span class="md-toc-item md-toc-h4" data-ref="n1044"><a class="md-toc-inner" href="#header-n1044">6.2.3 更改权限</a></span><span class="md-toc-item md-toc-h5" data-ref="n1045"><a class="md-toc-inner" href="#header-n1045">6.2.3.1 权限概述</a></span><span class="md-toc-item md-toc-h5" data-ref="n1057"><a class="md-toc-inner" href="#header-n1057">6.2.3.2 数字权限</a></span><span class="md-toc-item md-toc-h5" data-ref="n1077"><a class="md-toc-inner" href="#header-n1077">6.2.3.3 符号权限</a></span><span class="md-toc-item md-toc-h4" data-ref="n1094"><a class="md-toc-inner" href="#header-n1094">6.2.4 更改属组</a></span><span class="md-toc-item md-toc-h4" data-ref="n1103"><a class="md-toc-inner" href="#header-n1103">6.2.5 更改属主</a></span><span class="md-toc-item md-toc-h3" data-ref="n1112"><a class="md-toc-inner" href="#header-n1112">6.3 文件操作</a></span><span class="md-toc-item md-toc-h4" data-ref="n1113"><a class="md-toc-inner" href="#header-n1113">6.3.1 touch</a></span><span class="md-toc-item md-toc-h4" data-ref="n1141"><a class="md-toc-inner" href="#header-n1141">6.3.2 stat</a></span><span class="md-toc-item md-toc-h4" data-ref="n1145"><a class="md-toc-inner" href="#header-n1145">6.3.3 cat</a></span><span class="md-toc-item md-toc-h4" data-ref="n1154"><a class="md-toc-inner" href="#header-n1154">6.3.4 less</a></span><span class="md-toc-item md-toc-h4" data-ref="n1161"><a class="md-toc-inner" href="#header-n1161">6.3.5 tail</a></span><span class="md-toc-item md-toc-h4" data-ref="n1177"><a class="md-toc-inner" href="#header-n1177">6.3.6 head</a></span><span class="md-toc-item md-toc-h4" data-ref="n1191"><a class="md-toc-inner" href="#header-n1191">6.3.7 grep</a></span><span class="md-toc-item md-toc-h4" data-ref="n1227"><a class="md-toc-inner" href="#header-n1227">6.3.8 echo</a></span><span class="md-toc-item md-toc-h4" data-ref="n1240"><a class="md-toc-inner" href="#header-n1240">6.3.9 awk</a></span><span class="md-toc-item md-toc-h4" data-ref="n1304"><a class="md-toc-inner" href="#header-n1304">6.3.10 find</a></span><span class="md-toc-item md-toc-h4" data-ref="n1315"><a class="md-toc-inner" href="#header-n1315">6.3.11 read</a></span><span class="md-toc-item md-toc-h4" data-ref="n1319"><a class="md-toc-inner" href="#header-n1319">6.3.12 sort</a></span><span class="md-toc-item md-toc-h4" data-ref="n1332"><a class="md-toc-inner" href="#header-n1332">6.3.13 uniq</a></span><span class="md-toc-item md-toc-h3" data-ref="n1357"><a class="md-toc-inner" href="#header-n1357">6.4 文件压缩</a></span><span class="md-toc-item md-toc-h4" data-ref="n1358"><a class="md-toc-inner" href="#header-n1358">6.4.1 tar</a></span><span class="md-toc-item md-toc-h4" data-ref="n1382"><a class="md-toc-inner" href="#header-n1382">6.4.2 gzip</a></span><span class="md-toc-item md-toc-h4" data-ref="n1393"><a class="md-toc-inner" href="#header-n1393">6.4.3 gunzip</a></span><span class="md-toc-item md-toc-h4" data-ref="n1398"><a class="md-toc-inner" href="#header-n1398">6.4.4 zip</a></span><span class="md-toc-item md-toc-h4" data-ref="n1409"><a class="md-toc-inner" href="#header-n1409">6.4.5 unzip</a></span><span class="md-toc-item md-toc-h4" data-ref="n1420"><a class="md-toc-inner" href="#header-n1420">6.4.6 bzip2</a></span><span class="md-toc-item md-toc-h4" data-ref="n1426"><a class="md-toc-inner" href="#header-n1426">6.4.7 bunzip2</a></span><span class="md-toc-item md-toc-h3" data-ref="n1436"><a class="md-toc-inner" href="#header-n1436">6.5 文件编辑</a></span><span class="md-toc-item md-toc-h4" data-ref="n1437"><a class="md-toc-inner" href="#header-n1437">6.5.1 Vim</a></span><span class="md-toc-item md-toc-h4" data-ref="n1447"><a class="md-toc-inner" href="#header-n1447">6.5.2 打开文件</a></span><span class="md-toc-item md-toc-h4" data-ref="n1486"><a class="md-toc-inner" href="#header-n1486">6.5.3 插入模式</a></span><span class="md-toc-item md-toc-h4" data-ref="n1516"><a class="md-toc-inner" href="#header-n1516">6.5.4 命令模式</a></span><span class="md-toc-item md-toc-h5" data-ref="n1518"><a class="md-toc-inner" href="#header-n1518">6.5.4.1 移动光标</a></span><span class="md-toc-item md-toc-h5" data-ref="n1559"><a class="md-toc-inner" href="#header-n1559">6.5.4.2 选中文本</a></span><span class="md-toc-item md-toc-h5" data-ref="n1581"><a class="md-toc-inner" href="#header-n1581">6.5.4.3 撤销删除</a></span><span class="md-toc-item md-toc-h5" data-ref="n1637"><a class="md-toc-inner" href="#header-n1637">6.5.4.4 复制粘贴</a></span><span class="md-toc-item md-toc-h5" data-ref="n1671"><a class="md-toc-inner" href="#header-n1671">6.5.4.5 查找替换</a></span><span class="md-toc-item md-toc-h4" data-ref="n1725"><a class="md-toc-inner" href="#header-n1725">6.5.5 末行模式</a></span><span class="md-toc-item md-toc-h4" data-ref="n1762"><a class="md-toc-inner" href="#header-n1762">6.5.6 异常处理</a></span><span class="md-toc-item md-toc-h3" data-ref="n1774"><a class="md-toc-inner" href="#header-n1774">6.6 链接</a></span><span class="md-toc-item md-toc-h2" data-ref="n1805"><a class="md-toc-inner" href="#header-n1805">7. 进程管理</a></span><span class="md-toc-item md-toc-h3" data-ref="n1806"><a class="md-toc-inner" href="#header-n1806">7.1 查看进程</a></span><span class="md-toc-item md-toc-h3" data-ref="n1814"><a class="md-toc-inner" href="#header-n1814">7.2 进程 ID</a></span><span class="md-toc-item md-toc-h3" data-ref="n1836"><a class="md-toc-inner" href="#header-n1836">7.3 进程状态</a></span><span class="md-toc-item md-toc-h3" data-ref="n1883"><a class="md-toc-inner" href="#header-n1883">7.4 状态改变</a></span><span class="md-toc-item md-toc-h4" data-ref="n1884"><a class="md-toc-inner" href="#header-n1884">7.4.1 SIGCHLD </a></span><span class="md-toc-item md-toc-h4" data-ref="n1895"><a class="md-toc-inner" href="#header-n1895">7.4.2 wait</a></span><span class="md-toc-item md-toc-h4" data-ref="n1907"><a class="md-toc-inner" href="#header-n1907">7.4.3 waitpid</a></span><span class="md-toc-item md-toc-h2" data-ref="n1920"><a class="md-toc-inner" href="#header-n1920">8. 网络管理</a></span><span class="md-toc-item md-toc-h3" data-ref="n1921"><a class="md-toc-inner" href="#header-n1921">8.1 network</a></span><span class="md-toc-item md-toc-h3" data-ref="n1932"><a class="md-toc-inner" href="#header-n1932">8.2 ifconfig</a></span><span class="md-toc-item md-toc-h3" data-ref="n1948"><a class="md-toc-inner" href="#header-n1948">8.3 ping</a></span><span class="md-toc-item md-toc-h3" data-ref="n1963"><a class="md-toc-inner" href="#header-n1963">8.4 netstat</a></span><span class="md-toc-item md-toc-h2" data-ref="n1994"><a class="md-toc-inner" href="#header-n1994">9. 磁盘管理</a></span><span class="md-toc-item md-toc-h3" data-ref="n1995"><a class="md-toc-inner" href="#header-n1995">9.1 挂载概念</a></span><span class="md-toc-item md-toc-h3" data-ref="n2010"><a class="md-toc-inner" href="#header-n2010">9.2 lsblk</a></span><span class="md-toc-item md-toc-h3" data-ref="n2034"><a class="md-toc-inner" href="#header-n2034">9.3 df</a></span><span class="md-toc-item md-toc-h3" data-ref="n2047"><a class="md-toc-inner" href="#header-n2047">9.4 mount</a></span><span class="md-toc-item md-toc-h2" data-ref="n2072"><a class="md-toc-inner" href="#header-n2072">10. 防火墙</a></span><span class="md-toc-item md-toc-h3" data-ref="n2073"><a class="md-toc-inner" href="#header-n2073">10.1 概述</a></span><span class="md-toc-item md-toc-h3" data-ref="n2076"><a class="md-toc-inner" href="#header-n2076">10.2 状态</a></span><span class="md-toc-item md-toc-h3" data-ref="n2090"><a class="md-toc-inner" href="#header-n2090">10.3 放行</a></span><span class="md-toc-item md-toc-h2" data-ref="n2105"><a class="md-toc-inner" href="#header-n2105">11. Shell</a></span><span class="md-toc-item md-toc-h3" data-ref="n2106"><a class="md-toc-inner" href="#header-n2106">11.1 入门</a></span><span class="md-toc-item md-toc-h4" data-ref="n2107"><a class="md-toc-inner" href="#header-n2107">11.1.1 概念</a></span><span class="md-toc-item md-toc-h4" data-ref="n2111"><a class="md-toc-inner" href="#header-n2111">11.1.2 环境</a></span><span class="md-toc-item md-toc-h4" data-ref="n2129"><a class="md-toc-inner" href="#header-n2129">11.1.3 第一个shell</a></span><span class="md-toc-item md-toc-h3" data-ref="n2150"><a class="md-toc-inner" href="#header-n2150">11.2 注释</a></span><span class="md-toc-item md-toc-h3" data-ref="n2161"><a class="md-toc-inner" href="#header-n2161">11.3 变量</a></span><span class="md-toc-item md-toc-h4" data-ref="n2162"><a class="md-toc-inner" href="#header-n2162">11.3.1 定义变量</a></span><span class="md-toc-item md-toc-h4" data-ref="n2175"><a class="md-toc-inner" href="#header-n2175">11.3.2 使用变量</a></span><span class="md-toc-item md-toc-h4" data-ref="n2186"><a class="md-toc-inner" href="#header-n2186">11.3.3 只读变量</a></span><span class="md-toc-item md-toc-h4" data-ref="n2190"><a class="md-toc-inner" href="#header-n2190">11.3.4 删除变量</a></span><span class="md-toc-item md-toc-h4" data-ref="n2196"><a class="md-toc-inner" href="#header-n2196">11.3.5 字符变量</a></span><span class="md-toc-item md-toc-h5" data-ref="n2199"><a class="md-toc-inner" href="#header-n2199">11.3.5.1 引号</a></span><span class="md-toc-item md-toc-h5" data-ref="n2220"><a class="md-toc-inner" href="#header-n2220">11.3.5.2 拼接字符串</a></span><span class="md-toc-item md-toc-h5" data-ref="n2223"><a class="md-toc-inner" href="#header-n2223">11.3.5.3 获取字符串长度</a></span><span class="md-toc-item md-toc-h5" data-ref="n2227"><a class="md-toc-inner" href="#header-n2227">11.3.5.4 提取字符串</a></span><span class="md-toc-item md-toc-h3" data-ref="n2233"><a class="md-toc-inner" href="#header-n2233">11.4 数组</a></span><span class="md-toc-item md-toc-h4" data-ref="n2235"><a class="md-toc-inner" href="#header-n2235">11.4.1 定义数组</a></span><span class="md-toc-item md-toc-h4" data-ref="n2242"><a class="md-toc-inner" href="#header-n2242">11.4.2 读取数组</a></span><span class="md-toc-item md-toc-h4" data-ref="n2247"><a class="md-toc-inner" href="#header-n2247">11.4.3 获取长度</a></span><span class="md-toc-item md-toc-h3" data-ref="n2254"><a class="md-toc-inner" href="#header-n2254">11.5 运算符</a></span><span class="md-toc-item md-toc-h4" data-ref="n2256"><a class="md-toc-inner" href="#header-n2256">11.5.1 规则</a></span><span class="md-toc-item md-toc-h4" data-ref="n2267"><a class="md-toc-inner" href="#header-n2267">11.5.2 算术运算符</a></span><span class="md-toc-item md-toc-h4" data-ref="n2309"><a class="md-toc-inner" href="#header-n2309">11.5.3 字符运算符</a></span><span class="md-toc-item md-toc-h4" data-ref="n2339"><a class="md-toc-inner" href="#header-n2339">11.5.4 关系运算符</a></span><span class="md-toc-item md-toc-h4" data-ref="n2374"><a class="md-toc-inner" href="#header-n2374">11.5.5 布尔运算符</a></span><span class="md-toc-item md-toc-h4" data-ref="n2394"><a class="md-toc-inner" href="#header-n2394">11.5.6 逻辑运算符</a></span><span class="md-toc-item md-toc-h3" data-ref="n2412"><a class="md-toc-inner" href="#header-n2412">11.6 流程控制</a></span><span class="md-toc-item md-toc-h4" data-ref="n2413"><a class="md-toc-inner" href="#header-n2413">11.6.1 if</a></span><span class="md-toc-item md-toc-h4" data-ref="n2426"><a class="md-toc-inner" href="#header-n2426">11.6.2 for</a></span><span class="md-toc-item md-toc-h4" data-ref="n2432"><a class="md-toc-inner" href="#header-n2432">11.6.3 while</a></span><span class="md-toc-item md-toc-h4" data-ref="n2438"><a class="md-toc-inner" href="#header-n2438">11.6.4 case...esac</a></span><span class="md-toc-item md-toc-h3" data-ref="n2451"><a class="md-toc-inner" href="#header-n2451">11.7 函数</a></span><span class="md-toc-item md-toc-h4" data-ref="n2452"><a class="md-toc-inner" href="#header-n2452">11.7.1 输入</a></span><span class="md-toc-item md-toc-h4" data-ref="n2462"><a class="md-toc-inner" href="#header-n2462">11.7.2 读取</a></span><span class="md-toc-item md-toc-h1" data-ref="n2473"><a class="md-toc-inner" href="#header-n2473">三、Docker</a></span><span class="md-toc-item md-toc-h2" data-ref="n2474"><a class="md-toc-inner" href="#header-n2474">1. 基本概述</a></span><span class="md-toc-item md-toc-h2" data-ref="n2499"><a class="md-toc-inner" href="#header-n2499">2. 操作命令</a></span><span class="md-toc-item md-toc-h3" data-ref="n2500"><a class="md-toc-inner" href="#header-n2500">2.1 进程相关</a></span><span class="md-toc-item md-toc-h3" data-ref="n2519"><a class="md-toc-inner" href="#header-n2519">2.2 镜像相关</a></span><span class="md-toc-item md-toc-h3" data-ref="n2535"><a class="md-toc-inner" href="#header-n2535">2.3 容器相关</a></span><span class="md-toc-item md-toc-h2" data-ref="n2574"><a class="md-toc-inner" href="#header-n2574">3. 数据卷</a></span><span class="md-toc-item md-toc-h2" data-ref="n2623"><a class="md-toc-inner" href="#header-n2623">4. 应用部署</a></span><span class="md-toc-item md-toc-h3" data-ref="n2624"><a class="md-toc-inner" href="#header-n2624">4.1 MySQL</a></span><span class="md-toc-item md-toc-h3" data-ref="n2665"><a class="md-toc-inner" href="#header-n2665">4.2 Tomcat</a></span><span class="md-toc-item md-toc-h3" data-ref="n2688"><a class="md-toc-inner" href="#header-n2688">4.3 Nginx</a></span><span class="md-toc-item md-toc-h3" data-ref="n2714"><a class="md-toc-inner" href="#header-n2714">4.4 Redis</a></span><span class="md-toc-item md-toc-h2" data-ref="n2732"><a class="md-toc-inner" href="#header-n2732">5. 镜像原理</a></span><span class="md-toc-item md-toc-h3" data-ref="n2733"><a class="md-toc-inner" href="#header-n2733">5.1 底层原理</a></span><span class="md-toc-item md-toc-h3" data-ref="n2764"><a class="md-toc-inner" href="#header-n2764">5.2 镜像制作</a></span><span class="md-toc-item md-toc-h3" data-ref="n2768"><a class="md-toc-inner" href="#header-n2768">5.3 Dockerfile</a></span><span class="md-toc-item md-toc-h4" data-ref="n2769"><a class="md-toc-inner" href="#header-n2769">5.3.1 基本概述</a></span><span class="md-toc-item md-toc-h4" data-ref="n2857"><a class="md-toc-inner" href="#header-n2857">5.3.2 Centos</a></span><span class="md-toc-item md-toc-h4" data-ref="n2879"><a class="md-toc-inner" href="#header-n2879">5.3.3 Boot</a></span><span class="md-toc-item md-toc-h2" data-ref="n2897"><a class="md-toc-inner" href="#header-n2897">6. 服务编排</a></span><span class="md-toc-item md-toc-h3" data-ref="n2898"><a class="md-toc-inner" href="#header-n2898">6.1 基本介绍</a></span><span class="md-toc-item md-toc-h3" data-ref="n2918"><a class="md-toc-inner" href="#header-n2918">6.2 功能实现</a></span><span class="md-toc-item md-toc-h2" data-ref="n2945"><a class="md-toc-inner" href="#header-n2945">7. 私有仓库</a></span><span class="md-toc-item md-toc-h2" data-ref="n2960"><a class="md-toc-inner" href="#header-n2960">8. 虚拟机</a></span><span class="md-toc-item md-toc-h1" data-ref="n3005"><a class="md-toc-inner" href="#header-n3005">四、后会有期</a></span></p></div><p>&nbsp;</p><h1><a name='header-n8' class='md-header-anchor '></a>一、Git</h1><h2><a name='header-n9' class='md-header-anchor '></a>1. Git概述</h2><h3><a name='header-n10' class='md-header-anchor '></a>1.1 版本系统</h3><blockquote><p>SVN 是集中式版本控制系统，版本库是集中放在中央服务器的，而开发人员工作的时候，用的都是自己的电脑，所以首先要从中央服务器下载最新的版本，然后开发，开发完后，需要把自己开发的代码提交到中央服务器。</p><p>集中式版本控制工具缺点：服务器单点故障、容错性差</p><p>Git 是分布式版本控制系统（Distributed Version Control System，简称 DVCS） ，分为两种类型的仓库：</p><p>本地仓库和远程仓库：</p><ul><li>本地仓库：是在开发人员自己电脑上的 Git 仓库<span>		</span></li><li>远程仓库：是在远程服务器上的 Git 仓库</li></ul></blockquote><p>&nbsp;</p><h3><a name='header-n22' class='md-header-anchor '></a>1.2 工作流程</h3><p>1．从远程仓库中克隆代码到本地仓库</p><p>2．从本地仓库中 checkout 代码然后进行代码修改</p><p>3．在提交前先将代码提交到<strong>暂存区</strong></p><p>4．提交到本地仓库。本地仓库中保存修改的各个历史版本</p><p>5．修改完成后，需要和团队成员共享代码时，将代码push到远程仓库</p><p>&nbsp;</p><h3><a name='header-n29' class='md-header-anchor '></a>1.3 Git安装</h3><p>下载地址： <a href='https://git-scm.com/download' target='_blank' class='url'>https://git-scm.com/download</a></p><p>&nbsp;</p><h3><a name='header-n32' class='md-header-anchor '></a>1.4 代码托管</h3><p>Git 中存在两种类型的仓库，即本地仓库和远程仓库。那么我们如何搭建Git远程仓库呢？我们可以借助互联网上提供的一些代码托管服务来实现，其中比较常用的有 GitHub、码云、GitLab 等。</p><p>GitHub（地址：<a href='https://github.com/' target='_blank' class='url'>https://github.com/</a>）是一个面向开源及私有软件项目的托管平台，因为只支持 Git 作为唯一的版本库格式进行托管，故名 GitHub</p><p>码云（地址： <a href='https://gitee.com/' target='_blank' class='url'>https://gitee.com/</a>）是国内的一个代码托管平台，由于服务器在国内，所以相比于 GitHub，码云速度会更快</p><p>GitLab（地址： <a href='https://about.gitlab.com/' target='_blank' class='url'>https://about.gitlab.com/</a> ）是一个用于仓库管理系统的开源项目，使用 Git 作为代码管理工具，并在此基础上搭建起来的 web 服务</p><p>&nbsp;</p><hr /><p>&nbsp;</p><h2><a name='header-n40' class='md-header-anchor '></a>2. 环境配置</h2><p>安装 Git 后首先要设置用户名称和 email 地址，因为每次 Git 提交都会使用该用户信息，此信息和注册的代码托管平台的信息无关</p><p>设置用户信息：</p><ul><li>git config --global user.name “Seazean”</li><li>git config --global user.email “<a href='mailto:zhyzhyang@sina.com' target='_blank' class='url'>zhyzhyang@sina.com</a>”  //用户名和邮箱可以随意填写，不会校对</li></ul><p>查看配置信息：</p><ul><li>git config --list</li><li>git config user.name</li></ul><p>通过上面的命令设置的信息会保存在用户目录下 /.gitconfig 文件中</p><p>&nbsp;</p><hr /><p>&nbsp;</p><h2><a name='header-n58' class='md-header-anchor '></a>3. 本地仓库</h2><h3><a name='header-n59' class='md-header-anchor '></a>3.1 获取仓库</h3><ul><li><p><strong>本地仓库初始化</strong></p><ol start='' ><li><p>在电脑的任意位置创建一个空目录（例如 repo1）作为本地 Git 仓库</p></li><li><p>进入这个目录中，点击右键打开 Git bash 窗口</p></li><li><p>执行命令 <strong>git init</strong></p><p>如果在当前目录中看到 .git 文件夹（此文件夹为隐藏文件夹）则说明 Git 仓库创建成功</p></li></ol></li><li><p><strong>远程仓库克隆</strong>
通过 Git 提供的命令从远程仓库进行克隆，将远程仓库克隆到本地</p><p>命令：git clone 远程 Git 仓库地址（HTTPS 或者 SSH）</p></li><li><p>生成 SSH 公钥步骤</p><ul><li><p>设置账户</p></li><li><p>cd ~/.ssh（查看是否生成过 SSH 公钥）user 目录下</p></li><li><p>生成 SSH 公钥：<code>ssh-keygen -t rsa -C &quot;email&quot;</code></p><ul><li>-t 指定密钥类型，默认是 rsa ，可以省略</li><li>-C 设置注释文字，比如邮箱</li><li>-f 指定密钥文件存储文件名</li></ul></li><li><p>查看命令: cat ~/.ssh/id_rsa.pub</p></li><li><p>公钥测试命令: ssh -T <a href='mailto:git@github.com' target='_blank' class='url'>git@github.com</a></p></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><hr /><p>&nbsp;</p><p>&nbsp;</p><h3><a name='header-n100' class='md-header-anchor '></a>3.2 工作过程</h3><p><img src='https://img-blog.csdnimg.cn/78c8444835d84cd98695b2638bffa8f5.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><hr /><p>&nbsp;</p><h3><a name='header-n105' class='md-header-anchor '></a>3.3 文件操作</h3><h4><a name='header-n106' class='md-header-anchor '></a>3.3.1 常用命令</h4><figure><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>git status</td><td>查看 git 状态 （文件是否进行了添加、提交操作）</td></tr><tr><td>git add filename</td><td>添加，将指定文件添加到暂存区</td></tr><tr><td>git commit -m &#39;message&#39;</td><td>提交，将暂存区文件提交到本地仓库，删除暂存区的该文件</td></tr><tr><td>git commit --amend</td><td>修改 commit 的 message</td></tr><tr><td>git rm filename</td><td>删除，删除工作区的文件，不是仓库，需要提交</td></tr><tr><td>git mv filename</td><td>移动或重命名工作区文件</td></tr><tr><td>git reset filename</td><td>使用当前分支上的修改覆盖暂存区，<strong>将暂存区的文件取消暂存</strong></td></tr><tr><td>git checkout filename</td><td>使用暂存区的修改覆盖工作目录，用来撤销本次修改(危险)</td></tr><tr><td>git log</td><td>查看日志（ git 提交的历史日志）</td></tr><tr><td>git reflog</td><td>可以查看所有分支的所有操作记录（包括已经被删除的 commit 记录的操作）</td></tr></tbody></table></figure><p><strong>其他指令</strong>：可以跳过暂存区域直接从分支中取出修改，或者直接提交修改到分支中</p><ul><li>git commit -a 直接把所有文件的修改添加到暂存区然后执行提交</li><li>git checkout HEAD -- files 取出最后一次修改，可以用来进行回滚操作</li></ul><p>&nbsp;</p><hr /><p>&nbsp;</p><h4><a name='header-n150' class='md-header-anchor '></a>3.3.2 文件状态</h4><ul><li><p>Git 工作目录下的文件存在两种状态：</p><ul><li><p>untracked 未跟踪（未被纳入版本控制）</p></li><li><p>tracked 已跟踪（被纳入版本控制）</p><ul><li>Unmodified 未修改状态</li><li>Modified 已修改状态</li><li>Staged 已暂存状态</li></ul></li></ul></li><li><p>查看文件状态：文件的状态会随着我们执行 Git 的命令发生变化</p><ul><li>git status 查看文件状态</li><li>git status –s 查看更简洁的文件状态</li></ul></li></ul><p>&nbsp;</p><hr /><p>&nbsp;</p><h4><a name='header-n176' class='md-header-anchor '></a>3.3.3 文件忽略</h4><p>一般我们总会有些文件无需纳入Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以在工作目录中创建一个名为 .gitignore 的文件（文件名称固定），列出要忽略的文件模式。下面是一个示例：</p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang="sh"><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang="sh"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8.16406px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment"># no .a files</span></span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">*.a</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment"># but do track lib.a, even though you're ignoring .a files above</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">!lib.a</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment"># only ignore the TODO file in the current directory, not subdir/TODO</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">/TODO</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment"># ignore all files in the build/ directory</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">build/</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment"># ignore doc/notes.txt, but not doc/server/arch.txt</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">doc/*.txt</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment"># ignore all .pdf files in the doc/ directory</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">doc/**/*.pdf</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 383px;"></div><div class="CodeMirror-gutters" style="display: none; height: 383px;"></div></div></div></pre><p>&nbsp;</p><hr /><p>&nbsp;</p><p>&nbsp;</p><h2><a name='header-n183' class='md-header-anchor '></a>4. 远程仓库</h2><h3><a name='header-n184' class='md-header-anchor '></a>4.1 工作流程</h3><p>Git 有四个工作空间的概念，分别为 工作空间、暂存区、本地仓库、远程仓库。</p><p>pull = fetch + merge</p><p>fetch 是从远程仓库更新到本地仓库，pull是从远程仓库直接更新到工作空间中</p><p><img src='https://img-blog.csdnimg.cn/9373150e1c4b42829ec6ec189a5fe913.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>&nbsp;</p><hr /><p>&nbsp;</p><h3><a name='header-n193' class='md-header-anchor '></a>4.2 查看仓库</h3><p>git remote：显示所有远程仓库的简写  </p><p>git remote -v：显示所有远程仓库  </p><p>git remote show <shortname>：显示某个远程仓库的详细信息</p><p>&nbsp;</p><h3><a name='header-n198' class='md-header-anchor '></a>4.3 添加仓库</h3><p>git remote add <shortname><url>：添加一个新的远程仓库，并指定一个可以引用的简写</p><p>&nbsp;</p><h3><a name='header-n201' class='md-header-anchor '></a>4.4 克隆仓库</h3><p>git clone <url>(HTTPS or SSH)：克隆远程仓库</p><p>Git 克隆的是该 Git 仓库服务器上的几乎所有数据（包括日志信息、历史记录等），而不仅仅是复制工作所需要的文件，当你执行 git clone 命令的时候，默认配置下远程 Git 仓库中的每一个文件的每一个版本都将被拉取下来。</p><p>&nbsp;</p><h3><a name='header-n205' class='md-header-anchor '></a>4.5 删除仓库</h3><p>git remote rm <shortname>：移除远程仓库，从本地移除远程仓库的记录，并不会影响到远程仓库</p><p>&nbsp;</p><h3><a name='header-n208' class='md-header-anchor '></a>4.6 拉取仓库</h3><p>git fetch  <shortname>：从远程仓库获取最新版本到本地仓库，不会自动 merge  </p><p>git pull <shortname> <branchname>：从远程仓库获取最新版本并 merge 到本地仓库</p><p>注意：如果当前本地仓库不是从远程仓库克隆，而是本地创建的仓库，并且<strong>仓库中存在文件</strong>，此时再从远程仓库拉取文件的时候会报错（fatal: refusing to merge unrelated histories ），解决此问题可以在 git pull 命令后加入参数 --allow-unrelated-histories</p><p>&nbsp;</p><h3><a name='header-n213' class='md-header-anchor '></a>4.7 推送仓库</h3><p>git push <shortname><branchname>：上传本地指定分支到远程仓库</p><p>&nbsp;</p><p>&nbsp;</p><hr /><p>&nbsp;</p><h2><a name='header-n219' class='md-header-anchor '></a>5. 版本管理</h2><p><img src='https://img-blog.csdnimg.cn/4124f176a0fd43899f3fc94705660cfc.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p>命令：git reset --hard 版本唯一索引值</p><p>&nbsp;</p><p>&nbsp;</p><hr /><p>&nbsp;</p><h2><a name='header-n226' class='md-header-anchor '></a>6. 分支管理</h2><h3><a name='header-n227' class='md-header-anchor '></a>6.1 查看分支</h3><p>git branch：列出所有本地分支  </p><p>git branch -r：列出所有远程分支  </p><p>git branch -a：列出所有本地分支和远程分支</p><p>&nbsp;</p><h3><a name='header-n232' class='md-header-anchor '></a>6.2 创建分支</h3><p>git branch  branch-name：新建一个分支，但依然停留在当前分支</p><p>git checkout -b branch-name：新建一个分支，并切换到该分支</p><p>&nbsp;</p><h3><a name='header-n236' class='md-header-anchor '></a>6.3 推送分支 </h3><p>git push origin branch-name：推送到远程仓库，origin 是引用名</p><p>&nbsp;</p><h3><a name='header-n239' class='md-header-anchor '></a>6.4 切换分支</h3><p>git checkout branch-name：切换到 branch-name 分支</p><p>&nbsp;</p><h3><a name='header-n242' class='md-header-anchor '></a>6.5 合并分支</h3><p>git merge branch-name：合并指定分支到当前分支</p><p>有时候合并操作不会如此顺利。 如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没办法合并它们，同时会提示文件冲突。此时需要我们打开冲突的文件并修复冲突内容，最后执行 git add 命令来标识冲突已解决</p><p><span>	</span>![](<img src='https://img-blog.csdnimg.cn/ea6b8481d34347bc98d3785ca66c1e58.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><h3><a name='header-n247' class='md-header-anchor '></a>6.6 删除分支</h3><p>git branch -d branch-name：删除分支</p><p>git push origin –d branch-name：删除远程仓库中的分支   （origin 是引用名）</p><p>如果要删除的分支中进行了开发动作，此时执行删除命令并不会删除分支，如果坚持要删除此分支，可以将命令中的 -d 参数改为 -D：git branch -D branch-name</p><p>&nbsp;</p><hr /><p>&nbsp;</p><h2><a name='header-n254' class='md-header-anchor '></a>7. 标签管理</h2><h3><a name='header-n255' class='md-header-anchor '></a>7.1 查看标签</h3><p>git tag：列出所有 tag</p><p>git show tag-name：查看 tag 详细信息</p><p>标签作用：在开发的一些关键时期，使用标签来记录这些关键时刻，保存快照，例如发布版本、有重大修改、升级的时候、会使用标签记录这些时刻，来永久标记项目中的关键历史时刻</p><p>&nbsp;</p><h3><a name='header-n260' class='md-header-anchor '></a>7.2 新建标签</h3><p>git tag tag-name：新建标签，如（git tag v1.0.1）</p><p>&nbsp;</p><h3><a name='header-n263' class='md-header-anchor '></a>7.3 推送标签</h3><p>git push [remotename] [tagname]：推送到远程仓库</p><p>git push [remotename] --tags：推送所有的标签</p><p>&nbsp;</p><h3><a name='header-n267' class='md-header-anchor '></a>7.4 切换标签</h3><p>git checkout tag-name：切换标签</p><p>&nbsp;</p><h3><a name='header-n270' class='md-header-anchor '></a>7.5 删除标签</h3><p>git tag -d tag-name：删除本地标签</p><p>git push origin :refs/tags/ tag-name：删除远程标签</p><p>&nbsp;</p><hr /><p>&nbsp;</p><h2><a name='header-n276' class='md-header-anchor '></a>8. IDEA操作</h2><h3><a name='header-n277' class='md-header-anchor '></a>8.1 环境配置</h3><p>File → Settings 打开设置窗口，找到 Version Control 下的 git 选项</p><p>选择 git 的安装目录后可以点击 Test 按钮测试是否正确配置：D:\Program Files\Git\cmd\git.exe</p><p>&nbsp;</p><h3><a name='header-n281' class='md-header-anchor '></a>8.2 创建仓库</h3><p>1、VCS → Import into Version Control → Create Git Repository</p><p>2、选择工程所在的目录,这样就创建好本地仓库了</p><p>3、点击git后边的对勾,将当前项目代码提交到本地仓库</p><p><span>	</span>注意: 项目中的配置文件不需要提交到本地仓库中,提交时,忽略掉即可</p><p>&nbsp;</p><h3><a name='header-n287' class='md-header-anchor '></a>8.3 文件操作</h3><p>右键项目名打开菜单 Git → Add → commit</p><p>&nbsp;</p><h3><a name='header-n290' class='md-header-anchor '></a>8.4 版本管理</h3><p><img src='https://img-blog.csdnimg.cn/95323af602db46489c695f146e112444.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><ul><li><img src='https://img-blog.csdnimg.cn/645ea6ed4937428aa386c912e55b5d1d.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></li></ul><p>           </p><p>&nbsp;</p><p>&nbsp;</p><hr /><p>&nbsp;</p><h3><a name='header-n300' class='md-header-anchor '></a>8.5 分支管理</h3><ul><li>创建分支：VCS → Git → Branches → New Branch → 给分支起名字 → ok</li><li>切换分支：idea 右下角 Git → 选择要切换的分支 → checkout</li><li>合并分支：VCS → Git → Merge changes → 选择要合并的分支 → merge</li><li>删除分支：idea 右下角 → 选中要删除的分支 → Delete</li></ul><p>&nbsp;</p><hr /><p>&nbsp;</p><h3><a name='header-n313' class='md-header-anchor '></a>8.6 推送仓库</h3><ol start='' ><li>VCS → Git → Push → 点击 master Define remote</li><li>将远程仓库的 url 路径复制过来 → Push
<img src='https://img-blog.csdnimg.cn/c1bb418fcfd24d45bd9c320af291c09f.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></li></ol><p>&nbsp;</p><hr /><p>&nbsp;</p><h3><a name='header-n322' class='md-header-anchor '></a>8.7 克隆仓库</h3><p>File → Close Project → Checkout from Version Control → Git → 指定远程仓库的路径 → 指定本地存放的路径 → clone</p><p><img src='https://img-blog.csdnimg.cn/19638aae69444e27ba3b5727a6e7c34c.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr /><p>&nbsp;</p><p>&nbsp;</p><h1><a name='header-n331' class='md-header-anchor '></a>二、Linux</h1><h2><a name='header-n332' class='md-header-anchor '></a>1. 操作系统</h2><p>操作系统（Operation System），是管理计算机硬件与软件资源的计算机程序，同时也是计算机系统的内核与基石。操作系统需要处理管理与配置内存、决定系统资源供需的优先次序、控制输入设备与输出设备、操作网络与管理文件系统等基本事务，操作系统也提供一个让用户与系统交互的操作界面</p><p>操作系统作为接口的示意图：<img src='https://img-blog.csdnimg.cn/d8075e25bf4d45308b99635aeb31a74e.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>&nbsp;</p><hr /><p>&nbsp;</p><h2><a name='header-n339' class='md-header-anchor '></a>2. Linux系统</h2><h3><a name='header-n340' class='md-header-anchor '></a>2.1 系统介绍</h3><p>从内到位依次是硬件 → 内核层 → Shell 层 → 应用层 → 用户
<img src='https://img-blog.csdnimg.cn/1ca87dabb8a342a2825950fc8c8b41b4.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p>内核层：核心和基础，附着在硬件平台上，控制和管理系统内的各种资源，有效的组织进程的运行，扩展硬件的功能，提高资源利用效率，为用户提供安全可靠的应用环境。</p><p>Shell 层：与用户直接交互的界面。用户可以在提示符下输入命令行，由 Shell 解释执行并输出相应结果或者有关信息，所以我们也把  Shell 称作命令解释器，利用系统提供的丰富命令可以快捷而简便地完成许多工作。</p><p>&nbsp;</p><hr /><p>&nbsp;</p><h3><a name='header-n347' class='md-header-anchor '></a>2.2 文件系统</h3><p>Linux 文件系统目录结构和熟知的 windows 系统有较大区别，没有各种盘符的概念。根目录只有一个/，采用层级式的树状目录结构。</p><p><img src='https://img-blog.csdnimg.cn/f6c9bdab8d274417bfd2dc15bd95d0ec.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><p>&nbsp;</p><hr /><p>&nbsp;</p><h2><a name='header-n354' class='md-header-anchor '></a>3. 远程连接</h2><h3><a name='header-n355' class='md-header-anchor '></a>3.1 设置IP</h3><h4><a name='header-n356' class='md-header-anchor '></a>3.1.1 NAT</h4><p>首先设置虚拟机中 NAT 模式的选项，打开 VMware，点击编辑下的虚拟网络编辑器，设置 NAT 参数
<span>	</span><img src='https://img-blog.csdnimg.cn/e7e644c06cae413baba71bbf1598064b.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p><strong>注意</strong>：VMware Network Adapter VMnet8 保证是启用状态</p><p><span>	</span><img src='https://img-blog.csdnimg.cn/115cee5f566b4bc39dd029939141a3ad.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><h4><a name='header-n361' class='md-header-anchor '></a>3.1.2 静态IP</h4><p>在普通用户下不能修改网卡的配置信息；所以我们要切换到 root 用户进行 ip 配置：su root/su</p><ul><li><p>修改网卡配置文件：<code>vim /etc/sysconfig/network-scripts/ifcfg-ens33</code></p></li><li><p>修改文件内容</p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang="sh" style="break-inside: unset;"><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang="sh"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8.16406px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation" style=""><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-def">TYPE</span><span class="cm-operator">=</span>Ethernet</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-def">PROXY_METHOD</span><span class="cm-operator">=</span>none</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-def">BROWSER_ONLY</span><span class="cm-operator">=</span>no</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-def">BOOTPROTO</span><span class="cm-operator">=</span>static</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-def">IPADDR</span><span class="cm-operator">=</span><span class="cm-number">10</span>.2.111.62</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-def">NETMASK</span><span class="cm-operator">=</span><span class="cm-number">255</span>.255.252.0</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-def">GATEWAY</span><span class="cm-operator">=</span><span class="cm-number">10</span>.2.111.254</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-def">DEFROUTE</span><span class="cm-operator">=</span><span class="cm-builtin">yes</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-def">IPV4_FAILURE_FATAL</span><span class="cm-operator">=</span>no</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-def">IPV6INIT</span><span class="cm-operator">=</span><span class="cm-builtin">yes</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-def">IPV6_AUTOCONF</span><span class="cm-operator">=</span><span class="cm-builtin">yes</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-def">IPV6_DEFROUTE</span><span class="cm-operator">=</span><span class="cm-builtin">yes</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-def">IPV6_FAILURE_FATAL</span><span class="cm-operator">=</span>no</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-def">IPV6_ADDR_GEN_MODE</span><span class="cm-operator">=</span>stable-privacy</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-def">NAME</span><span class="cm-operator">=</span>ens33</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-def">UUID</span><span class="cm-operator">=</span>2c2371f1-ef29-4514-a568-c4904bd11c82</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-def">DEVICE</span><span class="cm-operator">=</span>ens33</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-def">ONBOOT</span><span class="cm-operator">=</span><span class="cm-atom">true</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-comment">###########################</span></span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">BOOTPROTO设置为静态static</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">IPADDR设置ip地址</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">NETMASK设置子网掩码</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">GATEWAY设置网关</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">ONBOOT设置为true在系统启动时是否激活网卡</span></pre><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">执行保存 :wq!</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 630px;"></div><div class="CodeMirror-gutters" style="display: none; height: 630px;"></div></div></div></pre></li></ul><ul><li><p>重启网络：systemctl restart network</p></li><li><p>查看IP：ifconfig</p></li><li><p>宿主机 ping 虚拟机，虚拟机 ping 宿主机</p></li><li><p>在虚拟机中访问网络，需要增加一块 NAT 网卡</p><ul><li>【虚拟机】--【设置】--【添加】</li><li><img src='https://img-blog.csdnimg.cn/38533b40cca54b88b2843407f0027057.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></li></ul></li></ul><p>&nbsp;</p><p>&nbsp;</p><hr /><p>&nbsp;</p><h3><a name='header-n388' class='md-header-anchor '></a>3.2 远程登陆</h3><p><strong>服务器维护工作</strong> 都是在 远程 通过 SSH 客户端 来完成的， 并没有图形界面， 所有的维护工作都需要通过命令来完成，Linux 服务器需要安装 SSH 相关服务</p><p>首先执行 sudo apt-get install openssh-server 指令，接下来用 xshell 连接</p><p><img src='https://img-blog.csdnimg.cn/c4bd117dd6ad47d79a191c4f4cc008f1.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p>先用普通用户登录，然后转成 root</p><p>&nbsp;</p><p>&nbsp;</p><hr /><p>&nbsp;</p><p>&nbsp;</p><h2><a name='header-n398' class='md-header-anchor '></a>4. 用户管理</h2><p>Linux 系统是一个多用户、多任务的操作系统。多用户是指在 Linux 操作系统中可以创建多个用户，而这些多用户又可以同时执行各自不同的任务，而互不影响</p><p>在 Linux 系统中，会存在着以下几个概念：</p><ul><li>用户名：用户的名称</li><li>用户所属的组：当前用户所属的组</li><li>用户的家目录：当前账号登录成功之后的目录，就叫做该用户的家目录</li></ul><p>&nbsp;</p><h3><a name='header-n409' class='md-header-anchor '></a>4.1 用户管理</h3><h4><a name='header-n410' class='md-header-anchor '></a>4.1.1 当前用户</h4><p>logname：用于显示目前用户的名称</p><ul><li>--help：在线帮助</li><li>--vesion：显示版本信息</li></ul><p>&nbsp;</p><h4><a name='header-n418' class='md-header-anchor '></a>4.1.2 切换用户</h4><p>su UserName：切换用户</p><p>su -c comman root：切换用户为 root 并在执行 comman 指令后退出返回原使用者</p><p>su：切换到 root 用户</p><p>&nbsp;</p><h4><a name='header-n423' class='md-header-anchor '></a>4.1.3 用户添加</h4><p>命令：useradd  [options]  用户名</p><p>参数说明：</p><ul><li>-c comment 指定一段注释性描述</li><li>-d 指定用户主目录，如果此目录不存在，则同时使用 -m 选项，可以创建主目录</li><li>-m 创建用户的主目录</li><li>-g 用户组，指定用户所属的用户组</li><li>-G 用户组，用户组 指定用户所属的附加组</li><li>-s Shell 文件 指定用户的登录 Shell</li><li>-u 用户号，指定用户的用户号，如果同时有 -o 选项，则可以重复使用其他用户的标识号。</li></ul><p>如何知道添加用户成功呢？ 通过指令 cat /etc/passwd 查看</p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang=""><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang=""><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8.16406px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">seazean:x:  1000:1000:Seazean:/home/seazean:/bin/bash</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">用户名 密码  用户ID 组ID &nbsp; 注释 &nbsp;  家目录 &nbsp; &nbsp; &nbsp;  shell程序</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 113px;"></div><div class="CodeMirror-gutters" style="display: none; height: 113px;"></div></div></div></pre><p>useradd -m Username 新建用户成功之后，会建立 home 目录，但是此时有问题没有指定 shell 的版本，不是我们熟知的 bash，功能上有很多限制，进行 <strong>sudo useradd -m -s /bin/bash Username</strong></p><p>&nbsp;</p><p>&nbsp;</p><h4><a name='header-n446' class='md-header-anchor '></a>4.1.4 用户密码</h4><p>系统安装好默认的 root 用户是没有密码的，需要给 root 设置一个密码 <strong>sudo passwd root</strong>.</p><ul><li><p>普通用户：<strong>sudo passwd UserName</strong></p></li><li><p>管理员用户：passwd [options] UserName</p><ul><li>-l：锁定密码，即禁用账号</li><li>-u：密码解锁</li><li>-d：使账号无密码</li><li>-f：强迫用户下次登录时修改密码</li></ul></li></ul><p>&nbsp;</p><h4><a name='header-n463' class='md-header-anchor '></a>4.1.5 用户权限</h4><p>usermod 命令通过修改系统帐户文件来修改用户账户信息</p><p>修改用户账号就是根据实际情况更改用户的有关属性，如用户号、主目录、用户组、登录 Shell 等</p><ul><li><p>普通用户：sudo usermod [options] Username</p></li><li><p>管理员用户：usermod [options] Username</p><ul><li>usermod <strong>-l</strong> newName Username</li><li>-l 新的登录名称</li></ul></li></ul><p>&nbsp;</p><h4><a name='header-n477' class='md-header-anchor '></a>4.1.6 用户删除</h4><p>删除用户账号就是要将 /etc/passwd 等系统文件中的该用户记录删除，必要时还删除用户的主目录</p><ul><li><p>普通用户：sudo userdel [options] Username</p></li><li><p>管理员用户：userdel [options] Username</p><ul><li>-f：强制删除用户，即使用户当前已登录</li><li>-r：删除用户的同时，删除与用户相关的所有文件</li></ul></li></ul><p>&nbsp;</p><hr /><p>&nbsp;</p><h3><a name='header-n492' class='md-header-anchor '></a>4.2 用户组管理</h3><h4><a name='header-n493' class='md-header-anchor '></a>4.2.1 组管理</h4><p>添加组：<strong>groupadd 组名</strong></p><p>创建用户的时加入组：useradd -m  -g 组名 用户名
​</p><h4><a name='header-n496' class='md-header-anchor '></a>4.2.2 添加用户组</h4><p>新增一个用户组（组名可见名知意，符合规范即可），然后将用户添加到组中，需要使用管理员权限</p><p>命令：groupadd  [options] Groupname</p><ul><li>-g GID 指定新用户组的组标识号（GID）</li><li>-o 一般与 -g 选项同时使用，表示新用户组的 GID 可以与系统已有用户组的 GID 相同</li></ul><p>新增用户组 Seazean：groupadd Seazean</p><p>&nbsp;</p><h4><a name='header-n506' class='md-header-anchor '></a>4.2.3 修改用户组</h4><p>需要使用管理员权限</p><p>命令：groupmod [options] Groupname</p><ul><li>-g GID 为用户组指定新的组标识号。</li><li>-o 与 -g 选项同时使用，用户组的新 GID 可以与系统已有用户组的 GID 相同</li><li>-n 新用户组 将用户组的名字改为新名字</li></ul><p>修改 Seazean 组名为 zhy：groupmod -n zhy Seazean</p><p>&nbsp;</p><h4><a name='header-n518' class='md-header-anchor '></a>4.2.4 删除用户组</h4><ul><li><p>普通用户：sudo groupdel Groupname </p></li><li><p>管理员用户：groupdel Groupname </p><ul><li>-f  用户的主组也继续删除</li><li>-h  显示帮助信息</li></ul></li></ul><p>&nbsp;</p><h4><a name='header-n530' class='md-header-anchor '></a>4.2.5 用户所属组</h4><p>查询用户所属组：groups Username</p><p>查看用户及组信息：id Username</p><p>创建用户的时加入组：useradd -m  -g Groupname Username</p><p>修改用户所属组：usermod -g Groupname Username</p><p>usermod常用选项：</p><ul><li>-d 用户的新主目录</li><li>-l  新的登录名称</li></ul><p>&nbsp;</p><h4><a name='header-n542' class='md-header-anchor '></a>4.2.6 gpasswd</h4><p>gpasswd 是 Linux 工作组文件 /etc/group 和 /etc/gshadow 管理工具，用于将一个用户添加到组或从组中删除</p><p>命令：gpasswd  选项  Username  Groupname</p><ul><li>-a 向组 GROUP 中添加用户 USER</li><li>-d 从组 GROUP 中添加或删除用户</li></ul><p><strong>查看用户组下所有用户（所有用户）</strong>：grep &#39;Groupname&#39; /etc/group</p><p>&nbsp;</p><p>&nbsp;</p><hr /><p>&nbsp;</p><p>&nbsp;</p><h2><a name='header-n556' class='md-header-anchor '></a>5. 系统管理</h2><h3><a name='header-n557' class='md-header-anchor '></a>5.1 man</h3><p>在控制台输入：命令名 -h/  -help/   --h  /空</p><p>可以看到命令的帮助文档</p><p><strong>man</strong> [指令名称]：查看帮助文档，比如 man ls，退出方式 q</p><p>&nbsp;</p><hr /><p>&nbsp;</p><h3><a name='header-n564' class='md-header-anchor '></a>5.2 date</h3><p>date 可以用来显示或设定系统的日期与时间</p><p>命令：date [options]</p><ul><li>-d&lt;字符串&gt;：显示字符串所指的日期与时间，字符串前后必须加上双引号；</li><li>-s&lt;字符串&gt;：根据字符串来设置日期与时间，字符串前后必须加上双引号</li><li>-u：显示 GMT</li><li>--version：显示版本信息</li></ul><p>查看时间：date → 2020年 11月 30日 星期一 17:10:54 CST</p><p>查看指定格式时间：date &quot;+%Y-%m-%d %H:%M:%S&quot; → 2020-11-30 17:11:44</p><p>设置日期指令：date -s “2019-12-23 19:21:00”</p><p>&nbsp;</p><hr /><p>&nbsp;</p><h3><a name='header-n582' class='md-header-anchor '></a>5.3 id</h3><p>id 会显示用户以及所属群组的实际与有效 ID，若两个 ID 相同则仅显示实际 ID；若仅指定用户名称，则显示目前用户的 ID</p><p>命令：id [-gGnru] [--help] [--version] [用户名称] //参数的顺序</p><ul><li>-g 或--group：显示用户所属群组的 ID</li><li>-G 或--groups：显示用户所属附加群组的 ID</li><li>-n 或--name：显示用户，所属群组或附加群组的名称。</li><li>-r 或--real：显示实际 ID</li><li>-u 或--user：显示用户 ID</li></ul><blockquote><p>id 命令参数虽然很多，但是常用的是不带参数的 id 命令，主要看 uid 和组信息</p></blockquote><p>&nbsp;</p><hr /><p>&nbsp;</p><h3><a name='header-n601' class='md-header-anchor '></a>5.4 sudo</h3><p>sudo：控制用户对系统命令的使用权限，通过 sudo 可以提高普通用户的操作权限</p><ul><li>-V 显示版本编号</li><li>-h 会显示版本编号及指令的使用方式说明</li><li>-l  显示出自己（执行 sudo 的使用者）的权限</li><li>-command 要以系统管理者身份（或以 -u 更改为其他人）执行的指令</li></ul><p> <strong>sudo -u root command  -l</strong>：指定 root 用户执行指令 command  </p><p>&nbsp;</p><hr /><p>&nbsp;</p><h3><a name='header-n616' class='md-header-anchor '></a>5.5 top</h3><p>top：用于实时显示 process 的动态</p><ul><li>-c：command 属性进行了命令补全</li><li>-p 进程号：显示指定 pid 的进程信息</li><li>-d 秒数：表示进程界面更新时间（每几秒刷新一次）</li><li>-H 表示线程模式</li></ul><p><code>top -Hp 进程 id</code>：分析该进程内各线程的 CPU 使用情况</p><p><img src='https://img-blog.csdnimg.cn/3d17a546d26445ddadb11621a5372e8f.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p><strong>各进程（任务）的状态监控属性解释说明：</strong></p><ul><li>PID — 进程 id</li><li>TID — 线程 id</li><li>USER — 进程所有者</li><li>PR — 进程优先级</li><li>NI — nice 值，负值表示高优先级，正值表示低优先级</li><li>VIRT — 进程使用的虚拟内存总量，单位 kb，VIRT=SWAP+RES</li><li>RES — 进程使用的、未被换出的物理内存大小，单位 kb，RES=CODE+DATA</li><li>SHR — 共享内存大小，单位 kb</li><li>S — 进程状态，D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程</li><li>%CPU — 上次更新到现在的 CPU 时间占用百分比</li><li>%MEM — 进程使用的物理内存百分比</li><li>TIME+ — 进程使用的 CPU 时间总计，单位 1/100 秒</li><li>COMMAND — 进程名称（命令名/命令行）</li></ul><p>&nbsp;</p><hr /><p>&nbsp;</p><h3><a name='header-n660' class='md-header-anchor '></a>5.6 ps</h3><p>Linux 系统中查看进程使用情况的命令是 ps 指令</p><p>命令：ps</p><ul><li>-e:  显示所有进程</li><li>-f:  全格式</li><li>a:  显示终端上的所有进程</li><li>u:  以用户的格式来显示进程信息</li><li>x:  显示后台运行的进程</li><li>-T：开启线程查看</li><li>-p：指定线程号</li></ul><p> 一般常用格式为 ps -ef 或者 ps aux 两种。显示的信息大体一致，略有区别：</p><ul><li>如果想查看进程的 CPU 占用率和内存占用率，可以使用 aux</li><li>如果想查看进程的父进程 ID 和完整的 COMMAND 命令，可以使用 ef</li></ul><p><code>ps -T -p &lt;pid&gt;</code>：显示某个进程的线程</p><p>&nbsp;</p><p><strong>ps 和 top 区别：</strong></p><ul><li>ps 命令：可以查看进程的瞬间信息，是系统在过去执行的进程的静态快照</li><li>top 命令：可以持续的监视进程的动态信息</li></ul><p>&nbsp;</p><hr /><p>&nbsp;</p><h3><a name='header-n695' class='md-header-anchor '></a>5.7 kill</h3><p>Linux kill 命令用于删除执行中的程序或工作，并不是让进程直接停止，而是给进程发一个信号，可以进入终止逻辑</p><p>命令：kill [-s &lt;信息名称或编号&gt;] [程序]　或　kill [-l &lt;信息编号&gt;]</p><ul><li>-l &lt;信息编号&gt;：若不加&lt;信息编号&gt;选项，则-l参数会列出全部的信息名称</li><li>-s &lt;信息名称或编号&gt;：指定要送出的信息</li><li>-KILL：强制杀死进程</li><li><strong>-9：彻底杀死进程（常用）</strong></li><li>[程序]  程序的 PID、PGID、工作编号</li></ul><p><code>kill 15642</code>.   <code>kill -KILL 15642</code>.    <code>kill -9 15642</code></p><p>杀死指定用户所有进程：</p><ol start='' ><li>过滤出 user 用户进程 ：<code>kill -9 $(ps -ef | grep user)</code></li><li>直接杀死：<code>kill -u user</code></li></ol><p>&nbsp;</p><hr /><p>&nbsp;</p><h3><a name='header-n719' class='md-header-anchor '></a>5.8 shutdown</h3><p>shutdown 命令可以用来进行关闭系统，并且在关机以前传送讯息给所有使用者正在执行的程序，shutdown 也可以用来重开机</p><p>普通用户：sudo shutdown [-t seconds] [-rkhncfF] time [message]</p><p>管理员用户：shutdown [-t seconds] [-rkhncfF] time [message]</p><ul><li>-t seconds：设定在几秒钟之后进行关机程序</li><li>-k：并不会真的关机，只是将警告讯息传送给所有使用者</li><li>-r：关机后重新开机</li><li>-h：关机后停机</li><li>-n：不采用正常程序来关机，用强迫的方式杀掉所有执行中的程序后自行关机</li><li>-c：取消目前已经进行中的关机动作</li><li>-f：关机时，不做 fcsk 动作（检查 Linux 档系统）</li><li>-F：关机时，强迫进行 fsck 动作</li><li>time：设定关机的时间</li><li>message：传送给所有使用者的警告讯息</li></ul><p>立即关机：<code>shutdown -h now</code>   或者   <code>shudown now</code></p><p>指定 1 分钟后关机并显示警告信息：<code>shutdown +1 &quot;System will shutdown after 1 minutes&quot;</code></p><p>指定 1 分钟后重启并发出警告信息：<code>shutdown –r +1 &quot;1分钟后关机重启&quot;</code></p><p>&nbsp;</p><hr /><p>&nbsp;</p><h3><a name='header-n750' class='md-header-anchor '></a>5.9 reboot</h3><p>reboot 命令用于用来重新启动计算机</p><p>命令：reboot [-n] [-w] [-d] [-f] [-i]</p><ul><li>-n：在重开机前不做将记忆体资料写回硬盘的动作</li><li>-w：并不会真的重开机，只是把记录写到 /var/log/wtmp 档案里</li><li>-d：不把记录写到 /var/log/wtmp 档案里（-n 这个参数包含了 -d）</li><li>-f：强迫重开机，不呼叫 shutdown 这个指令</li><li>-i：在重开机之前先把所有网络相关的装置先停止</li></ul><p>&nbsp;</p><hr /><p>&nbsp;</p><h3><a name='header-n767' class='md-header-anchor '></a>5.10 who</h3><p>who 命令用于显示系统中有哪些使用者正在上面，显示的资料包含了使用者 ID、使用的终端机、上线时间、CPU 使用量、动作等等</p><p>命令：who - [husfV] [user]</p><ul><li>-H 或 --heading：显示各栏位的标题信息列（常用 <code>who -H</code>）</li><li>-i 或 -u 或 --idle：显示闲置时间，若该用户在前一分钟之内有进行任何动作，将标示成 <code>.</code> 号，如果该用户已超过 24 小时没有任何动作，则标示出 <code>old</code> 字符串</li><li>-m：此参数的效果和指定 <code>am i</code> 字符串相同</li><li>-q 或--count：只显示登入系统的帐号名称和总人数</li><li>-s：此参数将忽略不予处理，仅负责解决who指令其他版本的兼容性问题</li><li>-w 或-T或--mesg或--message或--writable：显示用户的信息状态栏</li><li>--help：在线帮助</li><li>--version：显示版本信息</li></ul><p>&nbsp;</p><hr /><p>&nbsp;</p><h3><a name='header-n790' class='md-header-anchor '></a>5.11 systemctl</h3><p>命令：systemctl [command] [unit]</p><ul><li>--version  查看版本号</li><li>start：立刻启动后面接的 unit</li><li>stop：立刻关闭后面接的 unit</li><li>restart：立刻关闭后启动后面接的 unit，亦即执行 stop 再 start 的意思</li><li>reload：不关闭 unit 的情况下，重新载入配置文件，让设置生效</li><li>status：目前后面接的这个 unit 的状态，会列出有没有正在执行、开机时是否启动等信息</li><li>enable：设置下次开机时，后面接的 unit 会被启动</li><li>disable：设置下次开机时，后面接的 unit 不会被启动</li><li>is-active：目前有没有正在运行中</li><li>is-enable：开机时有没有默认要启用这个 unit</li><li>kill ：不要被 kill 这个名字吓着了，它其实是向运行 unit 的进程发送信号</li><li>show：列出 unit 的配置</li><li>mask：注销 unit，注销后你就无法启动这个 unit 了</li><li>unmask：取消对 unit 的注销</li></ul><p>&nbsp;</p><hr /><p>&nbsp;</p><h3><a name='header-n824' class='md-header-anchor '></a>5.12 timedatectl</h3><p>timedatectl用于控制系统时间和日期。可以查询和更改系统时钟于设定，同时可以设定和修改时区信息。在实际开发过程中，系统时间的显示会和实际出现不同步；我们为了校正服务器时间、时区会使用timedatectl命令</p><p>timedatectl：显示系统的时间信息</p><p>timedatectl status：显示系统的当前时间和日期</p><p>timedatectl | grep Time：查看当前时区</p><p>timedatectl list-timezones：查看所有可用的时区</p><p>timedatectl set-timezone &quot;Asia/Shanghai&quot;：设置本地时区为上海</p><p>timedatectl set-ntp true/false：启用/禁用时间同步</p><p>timedatectl set-time &quot;2020-12-20 20:45:00&quot;：时间同步关闭后可以设定时间</p><p>NTP 即 Network Time Protocol（网络时间协议），是一个互联网协议，用于同步计算机之间的系统时钟，timedatectl 实用程序可以自动同步你的Linux系统时钟到使用NTP的远程服务器</p><p>&nbsp;</p><hr /><p>&nbsp;</p><h3><a name='header-n837' class='md-header-anchor '></a>5.13 clear</h3><p>clear 命令用于清除屏幕</p><p>通过执行 clear 命令，就可以把缓冲区的命令全部清理干净</p><p>&nbsp;</p><hr /><p>&nbsp;</p><h3><a name='header-n843' class='md-header-anchor '></a>5.14 exit</h3><p>exit 命令用于退出目前的 shell</p><p>执行 exit 可使 shell 以指定的状态值退出。若不设置状态值参数，则 shell 以预设值退出。状态值 0 代表执行成功，其他值代表执行失败；exit 也可用在 script，离开正在执行的 script，回到 shell</p><p>命令：exit [状态值]</p><ul><li>0 表示成功（Zero - Success）</li><li>非 0 表示失败（Non-Zero  - Failure）</li><li>2 表示用法不当（Incorrect Usage）</li><li>127 表示命令没有找到（Command Not Found）</li><li>126 表示不是可执行的（Not an executable）</li><li>大于等于 128 信号产生</li></ul><p>&nbsp;</p><p>&nbsp;</p><hr /><p>&nbsp;</p><p>&nbsp;</p><h2><a name='header-n865' class='md-header-anchor '></a>6. 文件管理</h2><h3><a name='header-n866' class='md-header-anchor '></a>6.1 常用命令</h3><h4><a name='header-n867' class='md-header-anchor '></a>6.1.1 ls</h4><p>ls命令相当于我们在Windows系统中打开磁盘、或者打开文件夹看到的目录以及文件的明细。</p><p>命令：ls [options]  目录名称</p><ul><li>-a ：全部的文件，连同隐藏档( 开头为 . 的文件) 一起列出来(常用)</li><li>-d ：仅列出目录本身，而不是列出目录内的文件数据(常用)</li><li>-l  ：显示不隐藏的文件与文件夹的详细信息；(常用)</li><li><strong>ls -al = ll 命令</strong>：显示所有文件与文件夹的详细信息</li></ul><p>&nbsp;</p><h4><a name='header-n880' class='md-header-anchor '></a>6.1.2 pwd</h4><p>pwd 是 Print Working Directory 的缩写，也就是显示目前所在当前目录的命令</p><p>命令：pwd 选项</p><ul><li>-L<span>	</span>打印 $PWD 变量的值，如果它包含了当前的工作目录</li><li>-P<span>	</span>打印当前的物理路径，不带有任何的符号链接</li></ul><p>&nbsp;</p><h4><a name='header-n889' class='md-header-anchor '></a>6.1.3 cd</h4><p>cd 是 Change Directory 的缩写，这是用来变换工作目录的命令</p><p>命令：cd [相对路径或绝对路径] </p><ul><li>cd ~ ：表示回到根目录</li><li>cd .. ：返回上级目录</li></ul><ul><li><p><strong>相对路径</strong> 在输入路径时, 最前面不是以 <code>/</code> 开始的 , 表示相对<strong>当前目录</strong>所在的目录位置</p><ul><li>例如： /usr/share/doc </li></ul></li><li><p><strong>绝对路径</strong> 在输入路径时, 最前面是以 <code>/</code>  开始的, 表示从<strong>根目录</strong>开始的具体目录位置</p><ul><li>由 /usr/share/doc 到 /usr/share/man 时，可以写成： cd ../man</li><li>优点：定位准确, 不会因为 工作目录变化 而变化</li></ul></li></ul><p>&nbsp;</p><h4><a name='header-n911' class='md-header-anchor '></a>6.1.4 mkdir</h4><p>mkdir命令用于建立名称为 dirName 之子目录</p><p>命令：mkdir [-p] dirName</p><ul><li>-p 确保目录名称存在，不存在的就建一个，用来创建多级目录。</li></ul><p><code>mkdir -p aaa/bbb</code>：在 aaa 目录下，创建一个 bbb 的子目录。 若 aaa 目录原本不存在，则建立一个</p><p>&nbsp;</p><h4><a name='header-n919' class='md-header-anchor '></a>6.1.5 rmdir</h4><p>rmdir命令删除空的目录</p><p>命令：rmdir [-p] dirName</p><ul><li>-p 是当子目录被删除后使它也成为空目录的话，则顺便一并删除</li></ul><p><code>rmdir  -p aaa/bbb</code>：在 aaa 目录中，删除名为 bbb 的子目录。若 bbb 删除后，aaa 目录成为空目录，则 aaa 同时也会被删除</p><p>&nbsp;</p><h4><a name='header-n927' class='md-header-anchor '></a>6.1.6 cp</h4><p>cp 命令主要用于复制文件或目录</p><p>命令：cp  [options]  source... directory</p><ul><li>-a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合</li><li>-d：复制时保留链接。这里所说的链接相当于Windows系统中的快捷方式</li><li>-f：覆盖已经存在的目标文件而不给出提示</li><li>-i：与 -f 选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答 y 时目标文件将被覆盖</li><li>-p：除复制文件的内容外，还把修改时间和访问权限也复制到新文件中</li><li>-r/R：若给出的源文件是一个目录文件，此时将复制该目录下所有的<strong>子目录</strong>和文件</li><li>-l：不复制文件，只是生成链接文件</li></ul><p><code>cp –r aaa/*  ccc</code>：复制 aaa 下的所有文件到 ccc，不加参数 -r 或者 -R，只复制文件，而略过目录</p><p>&nbsp;</p><h4><a name='header-n947' class='md-header-anchor '></a>6.1.7 rm</h4><p>rm命令用于删除一个文件或者目录。</p><p>命令：rm [options] name...</p><ul><li>-i 删除前逐一询问确认。</li><li>-f 即使原档案属性设为唯读，亦直接删除，无需逐一确认</li><li>-r 将目录及以下之档案亦逐一删除，递归删除</li></ul><p>注：文件一旦通过 rm 命令删除，则无法恢复，所以必须格外小心地使用该命令</p><p>&nbsp;</p><h4><a name='header-n959' class='md-header-anchor '></a>6.1.8 mv</h4><p>mv 命令用来为文件或目录改名、或将文件或目录移入其它位置</p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang="shell"><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang="shell"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8.16406px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-builtin">mv</span> [options] <span class="cm-builtin">source</span> dest</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-builtin">mv</span> [options] <span class="cm-builtin">source</span>... directory</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 45px;"></div><div class="CodeMirror-gutters" style="display: none; height: 45px;"></div></div></div></pre><ul><li><p>-i：若指定目录已有同名文件，则先询问是否覆盖旧文件</p></li><li><p>-f：在 mv 操作要覆盖某已有的目标文件时不给任何指示</p><figure><table><thead><tr><th>命令格式</th><th>运行结果</th></tr></thead><tbody><tr><td>mv  文件名  文件名</td><td>将源文件名改为目标文件名</td></tr><tr><td>mv  文件名  目录名</td><td>将文件移动到目标目录</td></tr><tr><td>mv  目录名  目录名</td><td>目标目录已存在，将源目录移动到目标目录。目标目录不存在则改名</td></tr><tr><td>mv  目录名  文件名</td><td>出错</td></tr></tbody></table></figure><p>&nbsp;</p></li></ul><hr /><p>&nbsp;</p><h3><a name='header-n986' class='md-header-anchor '></a>6.2 文件属性</h3><h4><a name='header-n987' class='md-header-anchor '></a>6.2.1 基本属性</h4><p>Linux 系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。为了保护系统的安全性，Linux系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定</p><p><img src='https://img-blog.csdnimg.cn/ff1b6b15b6454bb7b926822853806dd2.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p>在Linux中第一个字符代表这个文件是目录、文件或链接文件等等。</p><ul><li>当为 d 则是目录</li><li>当为 - 则是文件</li><li>若是 l 则表示为链接文档 link file</li><li>若是 b 则表示为装置文件里面的可供储存的接口设备(可随机存取装置)</li><li>若是 c 则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)</li></ul><p>接下来的字符，以三个为一组，均为[rwx] 的三个参数组合。其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现[ - ]。</p><p><img src='https://img-blog.csdnimg.cn/5b2b0876551643bda0f5b8061919bd79.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p>从左至右用 0-9 这些数字来表示：</p><ul><li>第 0 位确定文件类型</li><li>第 1-3 位确定属主拥有该文件的权限</li><li>第 4-6 位确定属组拥有该文件的权限</li><li>第 7-9 位确定其他用户拥有该文件的权限</li></ul><p>&nbsp;</p><hr /><p>&nbsp;</p><h4><a name='header-n1017' class='md-header-anchor '></a>6.2.2 文件信息</h4><p>对于一个文件，都有一个特定的所有者，也就是对该文件具有所有权的用户（属主）；还有这个文件是属于哪个组的（属组）</p><ul><li>文件的【属主】有一套【读写执行权限rwx】</li><li>文件的【属组】有一套【读写执行权限rwx】</li></ul><p><img src='https://img-blog.csdnimg.cn/7880cb5edef24a97a2d6a7a23cc3c81c.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p><code>ls -l</code> 可以查看文件夹下文件的详细信息, 从左到右 依次是:</p><ul><li>权限（A 区域）： 第一个字符如果是 <code>d</code> 表示目录</li><li>硬链接数（B 区域）：通俗的讲就是有多少种方式, 可以访问当前目录和文件</li><li>属主（C 区域）：文件是所有者、或是叫做属主</li><li>属组（D 区域）： 文件属于哪个组</li><li>大小（E 区域）：文件大小</li><li>时间（F 区域）：最后一次访问时间</li><li>名称（G 区域）：文件的名称</li></ul><p>&nbsp;</p><hr /><p>&nbsp;</p><h4><a name='header-n1044' class='md-header-anchor '></a>6.2.3 更改权限</h4><h5><a name='header-n1045' class='md-header-anchor '></a>6.2.3.1 权限概述</h5><p>Linux 文件属性有两种设置方法，一种是数字，一种是符号</p><p>Linux 的文件调用权限分为三级 : 文件属主、属组、其他，利用 chmod 可以控制文件如何被他人所调用。</p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang="shell"><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang="shell"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8.16406px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-builtin">chmod</span> [-cfvR] [--help] [--version] mode file...</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">mode : 权限设定字串,格式: [ugoa...][[<span class="cm-operator">+</span><span class="cm-attribute">-</span><span class="cm-operator">=</span>][rwxX]...][,...]</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 90px;"></div><div class="CodeMirror-gutters" style="display: none; height: 90px;"></div></div></div></pre><ul><li>u 表示档案的拥有者，g 表示与该档案拥有者属于同一个 group 者，o 表示其他的人，a 表示这三者皆是</li><li>+表示增加权限、- 表示取消权限、= 表示唯一设定权限</li><li>r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有该档案是个子目录或者该档案已经被设定过为可执行</li></ul><p>&nbsp;</p><h5><a name='header-n1057' class='md-header-anchor '></a>6.2.3.2 数字权限</h5><p>命令：chmod [-R] xyz 文件或目录</p><ul><li>xyz : 就是刚刚提到的数字类型的权限属性，为 rwx 属性数值的相加。</li><li>-R : 进行递归(recursive)的持续变更，亦即连同次目录下的所有文件都会变更</li></ul><p>文件的权限字符为：[-rwxrwxrwx]， 这九个权限是三三一组的，我们使用数字来代表各个权限。</p><p><img src='https://img-blog.csdnimg.cn/8047407a223c42e08cd42e7ed728d86d.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p>各权限的数字对照表：[r]:4、[w]:2、[x]:1、[-]:0</p><p>每种身份（owner/group/others）的三个权限（r/w/x）分数是需要累加的，例如权限为：[-rwxrwx---] 分数是</p><ul><li>owner = rwx = 4+2+1 = 7</li><li>group = rwx = 4+2+1 = 7</li><li>others= --- = 0+0+0 = 0</li></ul><p>表示为：<code>chmod  -R 770 文件名</code></p><p>&nbsp;</p><h5><a name='header-n1077' class='md-header-anchor '></a>6.2.3.3 符号权限</h5><p><img src='https://img-blog.csdnimg.cn/c37c8a8facfa48caaf6adb64e486f33e.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><ul><li>user     属主权限</li><li>group  属组权限</li><li>others  其他权限</li><li>all  全部的身份</li></ul><p>我们就可以使用 <strong>u, g, o，a</strong> 来代表身份的权限！读写的权限可以写成 <strong>r, w, x</strong>。</p><p><code>chmod u=rwx,g=rx,o=r  a.txt</code>：将as.txt的权限设置为<strong>-rwxr-xr--</strong></p><p><code>chmod  a-r a.txt</code>：将文件的所有权限去除<strong>r</strong></p><p>&nbsp;</p><hr /><p>&nbsp;</p><h4><a name='header-n1094' class='md-header-anchor '></a>6.2.4 更改属组</h4><p>chgrp 命令用于变更文件或目录的所属群组</p><p>文件或目录权限的的拥有者由所属群组来管理，可以使用 chgrp 指令去变更文件与目录的所属群组</p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang="shell"><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang="shell"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8.16406px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">chgrp [-cfhRv][--help][--version][所属群组][文件或目录...]</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;">chgrp [-cfhRv][--help]<span class="cm-def">[--reference</span><span class="cm-operator">=</span>&lt;参考文件或目录&gt;][--version][文件或目录...]</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 90px;"></div><div class="CodeMirror-gutters" style="display: none; height: 90px;"></div></div></div></pre><p>chgrp -v root aaa：将文件 aaa 的属组更改成 root（其他也可以）</p><p>&nbsp;</p><p>&nbsp;</p><hr /><p>&nbsp;</p><h4><a name='header-n1103' class='md-header-anchor '></a>6.2.5 更改属主</h4><p>利用 chown 可以将档案的拥有者加以改变。</p><p>使用权限 : 管理员账户</p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang="shell"><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang="shell"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8.16406px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-builtin">chown</span> [–R] 属主名 文件名</span></pre></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-builtin">chown</span> [-R] 属主名:属组名 文件名</span></pre></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 45px;"></div><div class="CodeMirror-gutters" style="display: none; height: 45px;"></div></div></div></pre><p>chown root aaa：将文件aaa的属主更改成root</p><p>chown seazean:seazean aaa：将文件aaa的属主和属组更改为seazean</p><p>&nbsp;</p><hr /><p>&nbsp;</p><h3><a name='header-n1112' class='md-header-anchor '></a>6.3 文件操作</h3><h4><a name='header-n1113' class='md-header-anchor '></a>6.3.1 touch</h4><p>touch 命令用于创建文件、修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件</p><pre spellcheck="false" class="md-fences md-end-block ty-contain-cm modeLoaded" lang="shell"><div class="CodeMirror cm-s-inner CodeMirror-wrap" lang="shell"><div style="overflow: hidden; position: relative; width: 3px; height: 0px; top: 0px; left: 8.16406px;"><textarea autocorrect="off" autocapitalize="off" spellcheck="false" tabindex="0" style="position: absolute; bottom: -1em; padding: 0px; width: 1000px; height: 1em; outline: none;"></textarea></div><div class="CodeMirror-scrollbar-filler" cm-not-content="true"></div><div class="CodeMirror-gutter-filler" cm-not-content="true"></div><div class="CodeMirror-scroll" tabindex="-1"><div class="CodeMirror-sizer" style="margin-left: 0px; margin-bottom: 0px; border-right-width: 0px; padding-right: 0px; padding-bottom: 0px;"><div style="position: relative; top: 0px;"><div class="CodeMirror-lines" role="presentation"><div role="presentation" style="position: relative; outline: none;"><div class="CodeMirror-measure"><pre><span>xxxxxxxxxx</span></pre></div><div class="CodeMirror-measure"></div><div style="position: relative; z-index: 1;"></div><div class="CodeMirror-code" role="presentation"><div class="CodeMirror-activeline" style="position: relative;"><div class="CodeMirror-activeline-background CodeMirror-linebackground"></div><div class="CodeMirror-gutter-background CodeMirror-activeline-gutter" style="left: 0px; width: 0px;"></div><pre class=" CodeMirror-line " role="presentation"><span role="presentation" style="padding-right: 0.1px;"><span class="cm-builtin">touch</span> [-acfm][-d&lt;日期时间&gt;][-r&lt;参考文件或目录&gt;] [-t&lt;日期时间&gt;][--help][--version][文件或目录…]</span></pre></div></div></div></div></div></div><div style="position: absolute; height: 0px; width: 1px; border-bottom: 0px solid transparent; top: 68px;"></div><div class="CodeMirror-gutters" style="display: none; height: 68px;"></div></div></div></pre><ul><li>-a  改变档案的读取时间记录</li><li>-m 改变档案的修改时间记录</li><li>-c  假如目的档案不存在，不会建立新的档案。与 --no-create 的效果一样</li><li>-f  不使用，是为了与其他 unix 系统的相容性而保留</li><li>-r  使用参考档的时间记录，与 --file 的效果一样</li><li>-d 设定时间与日期，可以使用各种不同的格式</li><li>-t  设定档案的时间记录，格式与 date 指令相同</li><li>--no-create 不会建立新档案</li><li>--help 列出指令格式</li><li>--version 列出版本讯息</li></ul><p><code>touch t.txt</code>：创建 t.txt 文件</p><p><code>touch t{1..10}.txt</code>：创建10 个名为 t1.txt 到 t10.txt 的空文件</p><p><code>touch t.txt</code>：更改 t.txt 的访问时间为现在</p><p>&nbsp;</p><h4><a name='header-n1141' class='md-header-anchor '></a>6.3.2 stat</h4><p>stat 命令用于显示 inode 内容</p><p>命令：stat [文件或目录]</p><p>&nbsp;</p><h4><a name='header-n1145' class='md-header-anchor '></a>6.3.3 cat</h4><p>cat 是一个文本文件查看和连接工具，<strong>用于小文件</strong></p><p>命令：cat [-AbeEnstTuv] [--help] [--version] Filename</p><ul><li>-n  显示文件加上行号</li><li>-b  和 -n 相似，只不过对于空白行不编号</li></ul><p>&nbsp;</p><h4><a name='header-n1154' class='md-header-anchor '></a>6.3.4 less</h4><p>less 用于查看文件，但是 less 在查看之前不会加载整个文件，<strong>用于大文件</strong></p><p>命令：less [options] Filename</p><ul><li>-N  显示每行行号</li></ul><p>&nbsp;</p><h4><a name='header-n1161' class='md-header-anchor '></a>6.3.5 tail</h4><p>tail 命令可用于查看文件的内容，有一个常用的参数 <strong>-f</strong> 常用于查阅正在改变的日志文件</p><p>命令：tail  [options]  Filename</p><ul><li>-f  循环读取,动态显示文档的最后内容</li><li>-n  显示文件的尾部 n 行内容</li><li>-c 显示字节数</li><li>-nf 查看最后几行日志信息</li></ul><p><code>tail -f filename</code>：动态显示最尾部的内容</p><p><code>tail -n +2  txtfile.txt</code>：显示文件 txtfile.txt 的内容，从第 2 行至文件末尾</p><p><code>tail -n 2  txtfile.txt</code>：显示文件 txtfile.txt 的内容，最后 2 行</p><p>&nbsp;</p><h4><a name='header-n1177' class='md-header-anchor '></a>6.3.6 head</h4><p>head 命令可用于查看文件的开头部分的内容，有一个常用的参数 <strong>-n</strong> 用于显示行数，默认为 10</p><ul><li>-q 隐藏文件名</li><li>-v 显示文件名</li><li>-c 显示的字节数</li><li>-n 显示的行数</li></ul><p><code>head -n Filename</code>：查看文件的前一部分</p><p><code>head -n 20 Filename</code>：查看文件的前 20 行</p><p>&nbsp;</p><h4><a name='header-n1191' class='md-header-anchor '></a>6.3.7 grep</h4><p>grep 指令用于查找内容包含指定的范本样式的文件，若不指定任何文件名称，或是所给予的文件名为 -，则 grep 指令会从标准输入设备读取数据</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="shell" contenteditable="false" cid="n1193" mdtype="fences">grep [-abcEFGhHilLnqrsvVwxy][-A&lt;显示列数&gt;][-B&lt;显示列数&gt;][-C&lt;显示列数&gt;][-d&lt;进行动作&gt;][-e&lt;范本样式&gt;][-f&lt;范本文件&gt;][--help][范本样式][文件或目录...]
</pre><ul><li>-c 只输出匹配行的计数</li><li>-i 不区分大小写</li><li>-h 查询多文件时不显示文件名</li><li>-l 查询多文件时只输出包含匹配字符的文件名</li><li>-n 显示匹配行及行号</li><li>-s 不显示不存在或无匹配文本的错误信息</li><li>-v 显示不包含匹配文本的所有行</li><li>--color=auto 可以将找到的关键词部分加上颜色的显示</li></ul><p><strong>管道符 |</strong>：表示将前一个命令处理的结果传递给后面的命令处理</p><ul><li><code>grep aaaa Filename</code>：显示存在关键字 aaaa 的行</li><li><code>grep -n aaaa Filename</code>：显示存在关键字 aaaa 的行，且显示行号</li><li><code>grep -i aaaa Filename</code>：忽略大小写，显示存在关键字 aaaa 的行</li><li><code>grep -v aaaa Filename</code>：显示存在关键字 aaaa 的所有行</li><li><code>ps -ef | grep  sshd</code>：查找包含 sshd 进程的进程信息</li><li><code>ps -ef | grep -c sshd</code>：查找 sshd 相关的进程个数</li></ul><p>&nbsp;</p><p>&nbsp;</p><h4><a name='header-n1227' class='md-header-anchor '></a>6.3.8 echo</h4><p>将字符串输出到控制台 ,  通常和重定向联合使用</p><p>命令：echo string，如果字符串有空格, 为了避免歧义 请增加 双引号 或者 单引号</p><ul><li>通过 <code>命令 &gt; 文件</code>  将命令的成功结果覆盖指定文件内容</li><li>通过 <code>命令 &gt;&gt; 文件</code>   将命令的成功结果追加指定文件的后面</li><li>通过 <code>命令 &amp;&gt;&gt; 文件</code> 将 命令的失败结果追加指定文件的后面</li></ul><p><code>echo &quot;程序员&quot; &gt;&gt; a.txt</code>：将程序员追加到 a.txt 后面</p><p><code>cat 不存在的目录 &amp;&gt;&gt; error.log</code>：将错误信息追加到 error.log 文件</p><p>&nbsp;</p><h4><a name='header-n1240' class='md-header-anchor '></a>6.3.9 awk</h4><p>AWK 是一种处理文本文件的语言，是一个强大的文本分析工具</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="shell" contenteditable="false" cid="n1242" mdtype="fences">awk [options] 'script' var=value file(s)
awk [options] -f scriptfile var=value file(s)
</pre><ul><li><p>-F fs：指定输入文件折分隔符，fs 是一个字符串或者是一个正则表达式</p></li><li><p>-v：var=value 赋值一个用户定义变量</p></li><li><p>-f：从脚本文件中读取 awk 命令</p></li><li><p>$n：获取<strong>第几段</strong>内容</p></li><li><p>$0：获取<strong>当前行</strong> 内容</p></li><li><p>NF：表示当前行共有多少个字段</p></li><li><p>$NF：代表最后一个字段</p></li><li><p>$(NF-1)：代表倒数第二个字段</p></li><li><p>NR：代表处理的是第几行</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sh" contenteditable="false" cid="n1262" mdtype="fences">命令：awk 'BEGIN{初始化操作}{每行都执行} END{结束时操作}'   
文件名BEGIN{ 这里面放的是执行前的语句 }{这里面放的是处理每一行时要执行的语句}
END {这里面放的是处理完所有的行后要执行的语句 }
</pre></li></ul><p>&nbsp;</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="a.txt" contenteditable="false" cid="n1264" mdtype="fences">//准备数据
zhangsan 68 99 26
lisi 98 66 96
wangwu 38 33 86
zhaoliu 78 44 36
maq 88 22 66
zhouba 98 44 46
</pre><ul><li><p><code>cat a.txt | awk  &#39;/zhang|li/&#39;</code>：搜索含有 zhang  和 li 的学生成绩</p></li><li><p><code>awk &quot;/zhang|li/&quot; a.txt</code>：同上一个命令，效果一样</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1270" mdtype="fences">zhangsan 68 99 26
lisi 98 66 96
zhaoliu 78 44 36
</pre></li><li><p><code>cat a.txt | awk -F &#39; &#39; &#39;{print $1,$2,$3}&#39;</code>：按照空格分割，打印 一二三列内容</p></li><li><p><code>awk -F &#39; &#39; &#39;{OFS=&quot;\t&quot;}{print $1,$2,$3}&#39;</code>：按照制表符 tab 进行分割，打印一二三列
\b：退格      \f：换页      \n：换行      \r：回车      \t：制表符</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n1275" mdtype="fences">zhangsan	68	99
lisi	98	66
wangwu	38	33
zhaoliu	78	44
maq	88	22
zhouba	98	44
</pre></li><li><p><code>awk -F &#39;,&#39; &#39;{print  toupper($1)}&#39; a.txt</code>：根据逗号分割，打印内容，第一段大写</p><figure><table><thead><tr><th>函数名</th><th>含义</th><th>作用</th></tr></thead><tbody><tr><td>toupper()</td><td>upper</td><td>字符 转成 大写</td></tr><tr><td>tolower()</td><td>lower</td><td>字符 转成小写</td></tr><tr><td>length()</td><td>length</td><td>返回 字符长度</td></tr></tbody></table></figure></li><li><p><code>awk -F &#39; &#39; &#39;BEGIN{}{total=total+$4} END{print total}&#39; a.txt</code>：计算的是第4列的总分</p></li><li><p><code>awk -F &#39; &#39; &#39;BEGIN{}{total=total+$4} END{print total, NR}&#39; a.txt</code> ：查看总分, 总人数</p></li><li><p><code>awk -F &#39; &#39; &#39;BEGIN{}{total=total+$4} END{print total, NR, (total/NR)}&#39; a.txt</code>：查看总分, 总人数，平均数</p></li><li><p><code>cat a.txt | awk -F &#39; &#39; &#39;BEGIN{}{total=total+$4} END{print total}&#39;</code>：可以这样写</p></li></ul><p>&nbsp;</p><h4><a name='header-n1304' class='md-header-anchor '></a>6.3.10 find</h4><p>find 命令用来在指定目录下查找文件，如果使用该命令不设置任何参数，将在当前目录下查找子目录与文件，并且将查找到的子目录和文件全部进行显示</p><p>命令：find &lt;指定目录&gt; &lt;指定条件&gt; &lt;指定内容&gt;</p><ul><li><code>find . -name &quot;*.gz&quot;</code>：将目前目录及其子目录下所有延伸档名是 gz 的文件查询出来</li><li><code>find . -ctime -1</code>：将目前目录及其子目录下所有最近 1 天内更新过的文件查询出来</li><li><code>find / -name  &#39;seazean&#39;</code>：全局搜索 seazean</li></ul><p>&nbsp;</p><h4><a name='header-n1315' class='md-header-anchor '></a>6.3.11 read</h4><p>read 命令用于从标准输入读取数值</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="shell" contenteditable="false" cid="n1317" mdtype="fences">read [-ers] [-a aname] [-d delim] [-i text] [-n nchars] [-N nchars] [-p prompt] [-t timeout] [-u fd] [name ...]
</pre><p>&nbsp;</p><h4><a name='header-n1319' class='md-header-anchor '></a>6.3.12 sort</h4><p>Linux sort 命令用于将文本文件内容加以排序</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sh" contenteditable="false" cid="n1321" mdtype="fences">sort [-bcdfimMnr][文件]
</pre><ul><li>-n 依照数值的大小排序</li><li>-r 以相反的顺序来排序（sort 默认的排序方式是<strong>升序</strong>，改成降序，加 -r）</li><li>-u 去掉重复</li></ul><p>面试题：一列数字，输出最大的 4 个不重复的数</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sh" contenteditable="false" cid="n1330" mdtype="fences">sort -ur a.txt | head -n 4
sort -r a.txt | uniq |  head -n 4
</pre><p>&nbsp;</p><h4><a name='header-n1332' class='md-header-anchor '></a>6.3.13 uniq</h4><p>uniq 用于重复数据处理，使用前先 sort 排序</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sh" contenteditable="false" cid="n1334" mdtype="fences">uniq [OPTION]... [INPUT [OUTPUT]]
</pre><ul><li>-c 在数据行前出现的次数</li><li>-d 只打印重复的行，重复的行只显示一次</li><li>-D 只打印重复的行，重复的行出现多少次就显示多少次</li><li>-f 忽略行首的几个字段</li><li>-i 忽略大小写</li><li>-s 忽略行首的几个字母</li><li>-u 只打印唯一的行</li><li>-w 比较不超过 n 个字母</li></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr /><p>&nbsp;</p><h3><a name='header-n1357' class='md-header-anchor '></a>6.4 文件压缩</h3><h4><a name='header-n1358' class='md-header-anchor '></a>6.4.1 tar</h4><p>tar 的主要功能是打包、压缩和解压文件，tar 本身不具有压缩功能，是调用压缩功能实现的。</p><p>命令：tar  [必要参数]   [选择参数]   [文件] </p><ul><li>-c   产生 .tar 文件</li><li>-v   显示详细信息<span>	</span></li><li>-z   打包同时压缩</li><li>-f   指定压缩后的文件名</li><li>-x   解压 .tar 文件</li><li>-t   列出 tar 文件中包含的文件的信息</li><li>-r   附加新的文件到tar文件中</li></ul><p><code>tar -cvf txt.tar txtfile.txt</code>：将 txtfile.txt 文件打包（仅打包，不压缩）</p><p><code>tar -zcvf combine.tar.gz 1.txt 2.txt 3.txt</code>：将 123.txt 文件打包压缩（gzip）</p><p><code>tar -ztvf txt.tar.gz</code>：查看 tar 中有哪些文件</p><p><code>tar -zxvf Filename -C 目标路径</code>：解压</p><p>&nbsp;</p><p>&nbsp;</p><h4><a name='header-n1382' class='md-header-anchor '></a>6.4.2 gzip</h4><p>gzip命令用于压缩文件。</p><p>gzip是个使用广泛的压缩程序，文件经它压缩过后，其名称后面会多出&quot;.gz&quot;的扩展名</p><ul><li>gzip * ：压缩目录下的所有文件，删除源文件。不支持直接压缩目录</li><li>gzip -rv 目录名：递归压缩目录</li><li>gzip -dv *：解压文件并列出详细信息</li></ul><p>&nbsp;</p><h4><a name='header-n1393' class='md-header-anchor '></a>6.4.3 gunzip</h4><p>gunzip命令用于解压文件。用于解开被gzip压缩过的文件</p><p>命令：gunzip  [options]  [文件或者目录]</p><p>gunzip 001.gz ：解压001.gz文件</p><p>&nbsp;</p><h4><a name='header-n1398' class='md-header-anchor '></a>6.4.4 zip</h4><p>zip 命令用于压缩文件。</p><p>zip 是个使用广泛的压缩程序，文件经它压缩后会另外产生具有 <code>.zip</code> 扩展名的压缩文件</p><p>命令：zip  [必要参数]  [选择参数]  [文件] </p><ul><li>-q 不显示指令执行过程</li><li>-r 递归处理，将指定目录下的所有文件和子目录一并处理</li></ul><p><code>zip -q -r z.zip *</code>：将该目录的文件全部压缩</p><p>&nbsp;</p><h4><a name='header-n1409' class='md-header-anchor '></a>6.4.5 unzip</h4><p>unzip 命令用于解压缩 zip 文件，unzip 为 <code>.zip</code> 压缩文件的解压缩程序</p><p>命令：unzip  [必要参数]  [选择参数]  [文件] </p><ul><li>-l  查看压缩文件内所包含的文件</li><li>-d&lt;目录&gt; 指定文件解压缩后所要存储的目录。</li></ul><p><code>unzip -l z.zip</code> ：查看压缩文件中包含的文件</p><p><code>unzip -d ./unFiles z.zip</code>：把文件解压到指定的目录下</p><p>&nbsp;</p><h4><a name='header-n1420' class='md-header-anchor '></a>6.4.6 bzip2</h4><p>bzip2 命令是 <code>.bz2</code> 文件的压缩程序。</p><p>bzip2 采用新的压缩演算法，压缩效果比传统的 LZ77/LZ78 压缩演算法好，若不加任何参数，bzip2 压缩完文件后会产生 .bz2 的压缩文件，并删除原始的文件</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sh" contenteditable="false" cid="n1423" mdtype="fences">bzip2 [-cdfhkLstvVz][--repetitive-best][--repetitive-fast][- 压缩等级][要压缩的文件]
</pre><p>压缩：bzip2 a.txt</p><p>&nbsp;</p><h4><a name='header-n1426' class='md-header-anchor '></a>6.4.7 bunzip2</h4><p>bunzip2 命令是 <code>.bz2</code> 文件的解压缩程序。</p><p>命令：bunzip2  [-fkLsvV]  [.bz2压缩文件]</p><ul><li>-v　解压缩文件时，显示详细的信息。</li></ul><p>解压：bunzip2 -v a.bz2 </p><p>&nbsp;</p><hr /><p>&nbsp;</p><h3><a name='header-n1436' class='md-header-anchor '></a>6.5 文件编辑</h3><h4><a name='header-n1437' class='md-header-anchor '></a>6.5.1 Vim</h4><p>vim：是从 vi 发展出来的一个文本编辑器</p><ul><li>命令模式：在 Linux 终端中输入<code>vim 文件名</code> 就进入了命令模式，但不能输入文字</li><li>编辑模式：在命令模式下按 <code>i</code> 就会进入编辑模式，此时可以写入程式，按 Esc 可回到命令模式</li><li>末行模式：在命令模式下按 <code>:</code> 进入末行模式，左下角会有一个冒号，可以敲入命令并执行</li></ul><p>&nbsp;</p><h4><a name='header-n1447' class='md-header-anchor '></a>6.5.2 打开文件</h4><p>Ubuntu 默认没有安装 vim，需要先安装 vim，安装命令：<strong>sudo apt-get install vim</strong></p><p>Vim 有三种模式：命令模式（Command mode）、插入模式（Insert mode）、末行模式（Last Line mode）</p><figure><table><thead><tr><th style='text-align:center;' >Vim 使用的选项</th><th style='text-align:center;' >说明</th><th style='text-align:center;' >常用</th></tr></thead><tbody><tr><td style='text-align:center;' >vim filename</td><td style='text-align:center;' >打开或新建一个文件，将光标置于第一行首部</td><td style='text-align:center;' >常用</td></tr><tr><td style='text-align:center;' >vim -r filename</td><td style='text-align:center;' >恢复上次vim打开时崩溃的文件</td><td style='text-align:center;' >&nbsp;</td></tr><tr><td style='text-align:center;' >vim -R filename</td><td style='text-align:center;' >把指定的文件以只读的方式放入Vim编辑器</td><td style='text-align:center;' >&nbsp;</td></tr><tr><td style='text-align:center;' >vim + filename</td><td style='text-align:center;' >打开文件，将光标置于最后一行的首部</td><td style='text-align:center;' >常用</td></tr><tr><td style='text-align:center;' >vim +n filename</td><td style='text-align:center;' >打开文件，将光标置于n行的首部</td><td style='text-align:center;' >常用</td></tr><tr><td style='text-align:center;' >vim +/pattern filename</td><td style='text-align:center;' >打开文件，将光标置于第一个与pattern匹配的位置</td><td style='text-align:center;' >&nbsp;</td></tr><tr><td style='text-align:center;' >vim -c command filename</td><td style='text-align:center;' >对文件编辑前，先执行指定的命令</td><td style='text-align:center;' >&nbsp;</td></tr></tbody></table></figure><p>&nbsp;</p><hr /><p>&nbsp;</p><h4><a name='header-n1486' class='md-header-anchor '></a>6.5.3 插入模式</h4><p>在命令模式下，通过按下 i、I、a、A、o、O 这 6 个字母进入插入模式</p><figure><table><thead><tr><th style='text-align:center;' >快捷键</th><th style='text-align:center;' >功能描述</th></tr></thead><tbody><tr><td style='text-align:center;' >i</td><td style='text-align:center;' >在光标所在位置插入文本，光标后的文本向右移动</td></tr><tr><td style='text-align:center;' >I</td><td style='text-align:center;' >在光标所在行的行首插入文本，行首是该行的第一个非空白字符</td></tr><tr><td style='text-align:center;' >o</td><td style='text-align:center;' >在光标所在行的下面插入新的一行，光标停在空行首</td></tr><tr><td style='text-align:center;' >O</td><td style='text-align:center;' >在光标所在行的上面插入新的一行，光标停在空行首</td></tr><tr><td style='text-align:center;' >a</td><td style='text-align:center;' >在光标所在位置之后插入文本</td></tr><tr><td style='text-align:center;' >A</td><td style='text-align:center;' >在光标所在行的行尾插入文本</td></tr></tbody></table></figure><p>按下 ESC 键，离开插入模式，进入命令模式</p><p>因为我们是一个空文件，所以使用【I】或者【i】都可以</p><p>如果里面的文本很多，要使用【A】进入编辑模式，即在行末添加文本</p><p>&nbsp;</p><hr /><p>&nbsp;</p><h4><a name='header-n1516' class='md-header-anchor '></a>6.5.4 命令模式</h4><p>Vim 打开一个文件（文件可以存在，也可以不存在），默认进入命令模式。在该模式下， 输入的字符会被当做指令，而不会被当做要输入的文字</p><h5><a name='header-n1518' class='md-header-anchor '></a>6.5.4.1 移动光标</h5><figure><table><thead><tr><th style='text-align:center;' >快捷键</th><th style='text-align:center;' >功能描述</th></tr></thead><tbody><tr><td style='text-align:center;' >w</td><td style='text-align:center;' >光标移动至下一个单词的单词首</td></tr><tr><td style='text-align:center;' >b</td><td style='text-align:center;' >光标移动至上一个单词的单词首</td></tr><tr><td style='text-align:center;' >e</td><td style='text-align:center;' >光标移动至下一个单词的单词尾</td></tr><tr><td style='text-align:center;' >0</td><td style='text-align:center;' >光标移动至当前行的行首</td></tr><tr><td style='text-align:center;' >^</td><td style='text-align:center;' >行首, 第一个不是空白字符的位置</td></tr><tr><td style='text-align:center;' >$</td><td style='text-align:center;' >光标移动至当前行的行尾</td></tr><tr><td style='text-align:center;' >gg</td><td style='text-align:center;' >光标移动至文件开头</td></tr><tr><td style='text-align:center;' >G</td><td style='text-align:center;' >光标移动至文件末尾</td></tr><tr><td style='text-align:center;' >ngg</td><td style='text-align:center;' >光标移动至第n行</td></tr><tr><td style='text-align:center;' >nG</td><td style='text-align:center;' >光标移动至第n行</td></tr><tr><td style='text-align:center;' >:n</td><td style='text-align:center;' >光标移动至第n行</td></tr></tbody></table></figure><p>&nbsp;</p><hr /><p>&nbsp;</p><h5><a name='header-n1559' class='md-header-anchor '></a>6.5.4.2 选中文本</h5><p>在 vi/vim 中要选择文本，需要显示 visual 命令切换到<strong>可视模式</strong></p><p>vi/vim 中提供了三种可视模式，方便程序员的选择<strong>选中文本的方式</strong></p><p>按 ESC 可以放弃选中, 返回到<strong>命令模式</strong></p><figure><table><thead><tr><th>命令</th><th>模式</th><th>功能</th></tr></thead><tbody><tr><td>v</td><td>可视模式</td><td>从光标位置开始按照正常模式选择文本</td></tr><tr><td>V</td><td>可视化模式</td><td>选中光标经过的完整行</td></tr><tr><td>Ctrl + v</td><td>可是块模式</td><td>垂直方向选中文本</td></tr></tbody></table></figure><p>&nbsp;</p><h5><a name='header-n1581' class='md-header-anchor '></a>6.5.4.3 撤销删除</h5><p>在学习编辑命令之前,先要知道怎样撤销之前一次错误的编辑操作</p><figure><table><thead><tr><th>命令</th><th>英文</th><th>功能</th></tr></thead><tbody><tr><td>u</td><td>undo</td><td>撤销上次的命令(ctrl + z)</td></tr><tr><td>Ctrl + r</td><td>uredo</td><td>恢复撤销的命令</td></tr></tbody></table></figure><p>&nbsp;</p><p>删除的内容此时并没有真正的被删除，在剪切板中，按下 p 键，可以将删除的内容粘贴回来</p><figure><table><thead><tr><th style='text-align:center;' >快捷键</th><th style='text-align:center;' >功能描述</th></tr></thead><tbody><tr><td style='text-align:center;' >x</td><td style='text-align:center;' >删除光标所在位置的字符</td></tr><tr><td style='text-align:center;' >d</td><td style='text-align:center;' >删除移动命令对应的内容</td></tr><tr><td style='text-align:center;' >dd</td><td style='text-align:center;' >删除光标所在行的内容</td></tr><tr><td style='text-align:center;' >D</td><td style='text-align:center;' >删除光标位置到行尾的内容</td></tr><tr><td style='text-align:center;' >:n1,n2</td><td style='text-align:center;' >删除从 a1 到 a2 行的文本内容</td></tr></tbody></table></figure><p><strong>删除命令可以和移动命令连用, 以下是常见的组合命令(扩展):</strong></p><figure><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>dw</td><td>删除从光标位置到单词末尾</td></tr><tr><td>d}</td><td>删除从光标位置到段落末尾</td></tr><tr><td>dG</td><td>删除光标所行到文件末尾的所有内容</td></tr><tr><td>ndd</td><td>删除当前行（包括此行）到后 n 行内容</td></tr></tbody></table></figure><p>&nbsp;</p><hr /><p>&nbsp;</p><h5><a name='header-n1637' class='md-header-anchor '></a>6.5.4.4 复制粘贴</h5><p>vim 中提供有一个 被复制文本的缓冲区</p><ul><li>复制命令会将选中的文字保存在缓冲区</li><li>删除命令删除的文字会被保存在缓冲区</li><li>在需要的位置，使用粘贴命令可以将缓冲对的文字插入到光标所在的位置</li><li>vim 中的文本缓冲区只有一个，如果后续做过复制、剪切操作，之前缓冲区中的内容会被替换</li></ul><figure><table><thead><tr><th style='text-align:center;' >快捷键</th><th style='text-align:center;' >功能描述</th></tr></thead><tbody><tr><td style='text-align:center;' >y</td><td style='text-align:center;' >复制已选中的文本到剪切板</td></tr><tr><td style='text-align:center;' >yy</td><td style='text-align:center;' >将光标所在行复制到剪切板</td></tr><tr><td style='text-align:center;' >nyy</td><td style='text-align:center;' >复制从光标所在行到向下n行</td></tr><tr><td style='text-align:center;' >p</td><td style='text-align:center;' >将剪切板中的内容粘贴到光标后</td></tr><tr><td style='text-align:center;' >P</td><td style='text-align:center;' >将剪切板中的内容粘贴到光标前</td></tr></tbody></table></figure><p>注意：<strong>vim 中的文本缓冲区和系统的剪切板不是同一个</strong>，在其他软件中使用 Ctrl + C 复制的内容，不能在 vim 中通过 <code>p</code> 命令粘贴，可以在编辑模式下使用鼠标右键粘贴</p><p>&nbsp;</p><hr /><p>&nbsp;</p><h5><a name='header-n1671' class='md-header-anchor '></a>6.5.4.5 查找替换</h5><p>查找</p><figure><table><thead><tr><th style='text-align:center;' >快捷键</th><th style='text-align:center;' >功能描述</th></tr></thead><tbody><tr><td style='text-align:center;' >/abc</td><td style='text-align:center;' >从光标所在位置向后查找字符串 abc</td></tr><tr><td style='text-align:center;' >/^abc</td><td style='text-align:center;' >查找以 abc 为行首的行</td></tr><tr><td style='text-align:center;' >/abc$</td><td style='text-align:center;' >查找以 abc 为行尾的行</td></tr><tr><td style='text-align:center;' >?abc</td><td style='text-align:center;' >从光标所在位置向前查找字符串 abc</td></tr><tr><td style='text-align:center;' >*</td><td style='text-align:center;' >向后查找当前光标所在单词</td></tr><tr><td style='text-align:center;' >#</td><td style='text-align:center;' >向前查找当前光标所在单词</td></tr><tr><td style='text-align:center;' >n</td><td style='text-align:center;' >查找下一个，向同一方向重复上次的查找指令</td></tr><tr><td style='text-align:center;' >N</td><td style='text-align:center;' >查找上一个，向相反方向重复上次的查找指令</td></tr></tbody></table></figure><p>替换：</p><figure><table><thead><tr><th>命令</th><th>功能</th><th>工作模式</th></tr></thead><tbody><tr><td>r</td><td>替换当前字符</td><td>命令模式</td></tr><tr><td>R</td><td>替换当前行光标后的字符</td><td>替换模式</td></tr></tbody></table></figure><ul><li>光标选中要替换的字符</li><li><code>R</code> 命令可以进入替换模式，替换完成后，按下 ESC 可以回到命令模式</li><li>替换命令的作用就是不用进入编辑模式，对文件进行轻量级的修改</li></ul><p>&nbsp;</p><hr /><p>&nbsp;</p><h4><a name='header-n1725' class='md-header-anchor '></a>6.5.5 末行模式</h4><p>在命令模式下，按下 <code>:</code> 键进入末行模式</p><figure><table><thead><tr><th style='text-align:center;' >命令</th><th style='text-align:center;' >功能描述</th></tr></thead><tbody><tr><td style='text-align:center;' >:wq</td><td style='text-align:center;' >保存并退出 Vim 编辑器</td></tr><tr><td style='text-align:center;' >:wq!</td><td style='text-align:center;' >保存并强制退出 Vim 编辑器</td></tr><tr><td style='text-align:center;' >:q</td><td style='text-align:center;' >不保存且退出 Vim 编辑器</td></tr><tr><td style='text-align:center;' >:q!</td><td style='text-align:center;' >不保存且强制退出 Vim 编辑器</td></tr><tr><td style='text-align:center;' >:w</td><td style='text-align:center;' >保存但是不退出 Vim 编辑器</td></tr><tr><td style='text-align:center;' >:w!</td><td style='text-align:center;' >强制保存但是不退出 Vim 编辑器</td></tr><tr><td style='text-align:center;' >:w filename</td><td style='text-align:center;' >另存到 filename 文件</td></tr><tr><td style='text-align:center;' >x!</td><td style='text-align:center;' >保存文本，退出保存但是不退出 Vim 编辑器，更通用的命令</td></tr><tr><td style='text-align:center;' >ZZ</td><td style='text-align:center;' >直接退出保存但是不退出 Vim 编辑器</td></tr><tr><td style='text-align:center;' >:n</td><td style='text-align:center;' >光标移动至第 n 行行首</td></tr></tbody></table></figure><p>&nbsp;</p><h4><a name='header-n1762' class='md-header-anchor '></a>6.5.6 异常处理</h4><ul><li><p>如果 vim 异常退出, 在磁盘上可能会保存有 交换文件</p></li><li><p>下次再使用 vim 编辑文件时，会看到以下屏幕信息：</p><p><img src='https://img-blog.csdnimg.cn/46824a15346541f18f728bbd6c982b87.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p></li><li><p>ls -a 一下，会看到隐藏的 .swp 文件，删除了此文件即可</p></li></ul><p>&nbsp;</p><hr /><p>&nbsp;</p><h3><a name='header-n1774' class='md-header-anchor '></a>6.6 链接</h3><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sh" contenteditable="false" cid="n1775" mdtype="fences">ln [-sf] source_filename dist_filename
</pre><ul><li>-s：默认是实体链接，加 -s 为符号链接</li><li>-f：如果目标文件存在时，先删除目标文件</li></ul><p><img src='https://img-blog.csdnimg.cn/453b74d50cac475ebd96faba4b0af941.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p><strong>实体链接</strong>：</p><ul><li>在目录下创建一个条目，记录着文件名与 inode 编号，这个 inode 就是源文件的 inode</li><li>删除任意一个条目，文件还是存在，只要引用数量不为 0</li><li>不能跨越文件系统、不能对目录进行链接</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sh" contenteditable="false" cid="n1790" mdtype="fences">ln /etc/crontab .
ll
34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 crontab
34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 /etc/crontab
</pre><p><strong>符号链接</strong>：</p><ul><li><p>符号链接文件保存着源文件所在的绝对路径，在读取时会定位到源文件上，可以理解为 Windows 的快捷方式</p></li><li><p>当源文件被删除了，链接文件就打不开了</p></li><li><p>记录的是路径，所以可以为目录建立符号链接</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sh" contenteditable="false" cid="n1799" mdtype="fences">34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 /etc/crontab
53745909 lrwxrwxrwx. 1 root root 12 Jun 23 22:31 /root/crontab2 -&gt; /etc/crontab
</pre><p>&nbsp;</p></li></ul><p>&nbsp;</p><hr /><p>&nbsp;</p><p>&nbsp;</p><h2><a name='header-n1805' class='md-header-anchor '></a>7. 进程管理</h2><h3><a name='header-n1806' class='md-header-anchor '></a>7.1 查看进程</h3><p>ps 指令：查看某个时间点的进程信息</p><p>top 指令：实时显示进程信息</p><p>pstree：查看进程树</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sh" contenteditable="false" cid="n1810" mdtype="fences">pstree -A	#查看所有进程树
</pre><p>&nbsp;</p><hr /><p>&nbsp;</p><h3><a name='header-n1814' class='md-header-anchor '></a>7.2 进程 ID</h3><p>进程号：</p><ul><li>进程号为 0 的进程通常是调度进程，常常被称为交换进程（swapper），该进程是内核的一部分，它并不执行任何磁盘上的程序，因此也被称为系统进程</li><li>进程号为 1 是 init 进程，是一个守护进程，在自举过程结束时由内核调用，init 进程绝不会终止，是一个普通的用户进程，但是它以超级用户特权运行</li></ul><p>父进程 ID 为 0 的进程通常是内核进程，作为系统<strong>自举过程</strong>的一部分而启动，init 进程是个例外，它的父进程是 0，但它是用户进程</p><ul><li>主存 = RAM + BIOS 部分的 ROM</li><li>DISK：存放 OS 和 Bootloader</li><li>BIOS：基于 I/O 处理系统</li><li>Bootloader：加载 OS，将 OS 放入内存</li></ul><p>自举程序存储在内存中 ROM，<strong>用来加载操作系统</strong>，初始化 CPU、寄存器、内存等。CPU 的程序计数器指自举程序第一条指令，当计算机<strong>通电</strong>，CPU 开始读取并执行自举程序，将操作系统（不是全部，只是启动计算机的那部分程序）装入 RAM 中，这个过程是自举过程。装入完成后程序计数器设置为 RAM 中操作系统的<strong>第一条指令</strong>，接下来 CPU 将开始执行（启动）操作系统的指令</p><p>存储在 ROM 中保留很小的自举装入程序，完整功能的自举程序保存在磁盘的启动块上，启动块位于磁盘的固定位，拥有启动分区的磁盘称为启动磁盘或系统磁盘（C 盘）</p><p>&nbsp;</p><hr /><p>&nbsp;</p><h3><a name='header-n1836' class='md-header-anchor '></a>7.3 进程状态</h3><figure><table><thead><tr><th>状态</th><th>说明</th></tr></thead><tbody><tr><td>R</td><td>running or runnable (on run queue) 正在执行或者可执行，此时进程位于执行队列中</td></tr><tr><td>D</td><td>uninterruptible sleep (usually I/O) 不可中断阻塞，通常为 IO 阻塞</td></tr><tr><td>S</td><td>interruptible sleep (waiting for an event to complete) 可中断阻塞，此时进程正在等待某个事件完成</td></tr><tr><td>Z</td><td>zombie (terminated but not reaped by its parent) 僵死，进程已经终止但是尚未被其父进程获取信息</td></tr><tr><td>T</td><td>stopped (either by a job control signal or because it is being traced) 结束，进程既可以被作业控制信号结束，也可能是正在被追踪</td></tr></tbody></table></figure><p>孤儿进程：</p><ul><li>一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程</li><li>孤儿进程将被 init 进程所收养，并由 init 进程对它们完成状态收集工作，所以孤儿进程不会对系统造成危害</li></ul><p>僵尸进程：</p><ul><li>一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过 wait() 或 waitpid() 获取了子进程信息后才会释放。如果子进程退出，而父进程并没有调用 wait() 或 waitpid()，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵尸进程</li><li>僵尸进程通过 ps 命令显示出来的状态为 Z（zombie）</li><li>系统所能使用的进程号是有限的，产生大量僵尸进程，会导致系统没有可用的进程号而不能产生新的进程</li><li>要消灭系统中大量的僵尸进程，只需要将其父进程杀死，此时僵尸进程就会变成孤儿进程，从而被 init 进程所收养，这样 init 进程就会释放所有的僵尸进程所占有的资源，从而结束僵尸进程</li></ul><p>补充：</p><ul><li>守护进程(daemon)是一类在后台运行的特殊进程，用于执行特定的系统任务。</li><li>守护进程是<strong>脱离于终端</strong>并且在后台运行的进程，脱离终端是为了避免在执行的过程中的信息在终端上显示，并且进程也不会被任何终端所产生的终端信息所打断</li><li>很多守护进程在系统引导的时候启动，并且一直运行直到系统关闭；另一些只在需要的时候才启动，完成任务后就自动结束</li></ul><p>&nbsp;</p><hr /><p>&nbsp;</p><h3><a name='header-n1883' class='md-header-anchor '></a>7.4 状态改变</h3><h4><a name='header-n1884' class='md-header-anchor '></a>7.4.1 SIGCHLD </h4><p>当一个子进程改变了它的状态时（停止运行，继续运行或者退出），有两件事会发生在父进程中：</p><ul><li>得到 SIGCHLD 信号</li><li>waitpid() 或者 wait() 调用会返回</li></ul><p>子进程发送的 SIGCHLD 信号包含了子进程的信息，比如进程 ID、进程状态、进程使用 CPU 的时间等；在子进程退出时进程描述符不会立即释放，父进程通过 wait() 和 waitpid() 来获得一个已经退出的子进程的信息，释放子进程的 PCB</p><p>&nbsp;</p><hr /><p>&nbsp;</p><h4><a name='header-n1895' class='md-header-anchor '></a>7.4.2 wait</h4><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="c" contenteditable="false" cid="n1896" mdtype="fences">pid_t wait(int *status)
</pre><p>参数：status 用来保存被收集的子进程退出时的状态，如果不关心子进程<strong>如何</strong>销毁，可以设置这个参数为 NULL</p><p>父进程调用 wait() 会一直阻塞，直到收到一个子进程退出的 SIGCHLD 信号，wait() 函数就会销毁子进程并返回</p><ul><li>成功，返回被收集的子进程的进程 ID</li><li>失败，返回 -1，同时 errno 被置为 ECHILD（如果调用进程没有子进程，调用就会失败）</li></ul><p>&nbsp;</p><hr /><p>&nbsp;</p><h4><a name='header-n1907' class='md-header-anchor '></a>7.4.3 waitpid</h4><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="c" contenteditable="false" cid="n1908" mdtype="fences">pid_t waitpid(pid_t pid, int *status, int options)
</pre><p>作用和 wait() 完全相同，只是多了两个可控制的参数 pid 和 options</p><ul><li>pid：指示一个子进程的 ID，表示只关心这个子进程退出的 SIGCHLD 信号；如果 pid=-1 时，那么和 wait() 作用相同，都是关注所有子进程退出的 SIGCHLD 信号</li><li>options：主要有 WNOHANG 和 WUNTRACED 两个，WNOHANG 可以使 waitpid() 调用变成非阻塞的，就是会立即返回，父进程可以继续执行其它任务</li></ul><p>&nbsp;</p><p>&nbsp;</p><hr /><p>&nbsp;</p><p>&nbsp;</p><h2><a name='header-n1920' class='md-header-anchor '></a>8. 网络管理</h2><h3><a name='header-n1921' class='md-header-anchor '></a>8.1 network</h3><ul><li>启动：service network start</li><li>停止：service network stop</li><li>重启：service network restart</li></ul><p>&nbsp;</p><hr /><p>&nbsp;</p><h3><a name='header-n1932' class='md-header-anchor '></a>8.2 ifconfig</h3><p>ifconfig 是 Linux 中用于显示或配置网络设备的命令，英文全称是 network interfaces configuring</p><p>ifconfig 命令用于显示或设置网络设备。ifconfig 可设置网络设备的状态，或是显示目前的设置</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sh" contenteditable="false" cid="n1935" mdtype="fences">ifconfig [网络设备][down up -allmulti -arp -promisc][add&lt;地址&gt;][del&lt;地址&gt;][&lt;hw&lt;网络设备类型&gt;&lt;硬件地址&gt;][io_addr&lt;I/O地址&gt;][irq&lt;IRQ地址&gt;][media&lt;网络媒介类型&gt;][mem_start&lt;内存地址&gt;][metric&lt;数目&gt;][mtu&lt;字节&gt;][netmask&lt;子网掩码&gt;][tunnel&lt;地址&gt;][-broadcast&lt;地址&gt;][-pointopoint&lt;地址&gt;][IP地址]
</pre><ul><li><p><code>ifconfig</code>：显示激活的网卡信息  ens
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Tool/网卡信息.png"  /></p><p>ens33（或 eth0）表示第一块网卡，IP地址是 192.168.0.137，广播地址 broadcast 192.168.0.255，掩码地址netmask 255.255.255.0 ，inet6 对应的是 ipv6</p><p>lo 是表示主机的<strong>回坏地址</strong>，用来测试一个网络程序，但又不想让局域网或外网的用户能够查看，只能在此台主机上运行和查看所用的网络接口 </p></li><li><p>ifconfig ens33 down：关闭网卡</p></li><li><p>ifconfig ens33 up：启用网卡</p></li></ul><p>&nbsp;</p><hr /><p>&nbsp;</p><h3><a name='header-n1948' class='md-header-anchor '></a>8.3 ping</h3><p>ping 命令用于检测主机</p><p>执行 ping 指令会使用 ICMP 传输协议，发出要求回应的信息，若远端主机的网络功能没有问题，就会回应该信息</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="shell" contenteditable="false" cid="n1951" mdtype="fences">ping [-dfnqrRv][-c&lt;完成次数&gt;][-i&lt;间隔秒数&gt;][-I&lt;网络界面&gt;][-l&lt;前置载入&gt;][-p&lt;范本样式&gt;][-s&lt;数据包大小&gt;][-t&lt;存活数值&gt;][主机名称或IP地址]
</pre><ul><li><p>-c&lt;完成次数&gt;：设置完成要求回应的次数；</p></li><li><p><code>ping -c 2 www.baidu.com</code>
<img src='https://img-blog.csdnimg.cn/581cfe71d7124b54ada9567d66d7715c.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p>icmp_seq：ping 序列，从1开始</p><p>ttl：IP 生存时间值</p><p>time：响应时间,数值越小，联通速度越快</p></li></ul><p>&nbsp;</p><hr /><p>&nbsp;</p><h3><a name='header-n1963' class='md-header-anchor '></a>8.4 netstat</h3><p>netstat 命令用于显示网络状态</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sh" contenteditable="false" cid="n1965" mdtype="fences">netstat [-acCeFghilMnNoprstuvVwx][-A&lt;网络类型&gt;][--ip]
</pre><ul><li>-a   显示所有连线中的 Socket，显示详细的连接状况</li><li>-i    显示网络界面信息表单，显示网卡列表</li><li>-p  显示正在使用 Socket 的程序识别码和程序名称</li><li>-n  显示使用 IP 地址，而不通过域名服务器</li><li>-t   显示 TCP 传输协议的连线状况。</li><li>-u  显示 UDP 传输协议的连线状况</li><li><strong>-aptn：查看所有 TCP 开启端口</strong></li><li><strong>-apun：查看所有 UDP 开启端口</strong></li></ul><p>补充：</p><ul><li>netstat -apn | grep port：查看指定端口号</li><li>lsof -i:port ：查看指定端口号</li></ul><p>&nbsp;</p><p>&nbsp;</p><hr /><p>&nbsp;</p><p>&nbsp;</p><h2><a name='header-n1994' class='md-header-anchor '></a>9. 磁盘管理</h2><h3><a name='header-n1995' class='md-header-anchor '></a>9.1 挂载概念</h3><p>在安装 Linux 系统时设立的各个分区，如根分区、/boot 分区等都是自动挂载的，也就是说不需要人为操作，开机就会自动挂载。但是光盘、U 盘等存储设备如果需要使用，就必须人为的进行挂载</p><p>在 Windows 下插入 U 盘也是需要挂载（分配盘符）的，只不过 Windows 下分配盘符是自动的。其实挂载可以理解为 Windows 当中的分配盘符，只不过 Windows 当中是以英文字母 ABCD 等作为盘符，而 Linux 是拿系统目录作为盘符，当然 Linux 当中也不叫盘符，而是称为挂载点，而把为分区或者光盘等存储设备分配一个挂载点的过程称为挂载</p><p>Linux 中的根目录以外的文件要想被访问，需要将其关联到根目录下的某个目录来实现，这种关联操作就是挂载，这个目录就是挂载点，解除次关联关系的过程称之为卸载</p><p>挂载点的目录需要以下几个要求：</p><ul><li>目录要先存在，可以用 mkdir 命令新建目录</li><li>挂载点目录不可被其他进程使用到</li><li>挂载点下原有文件将被隐藏</li></ul><p>&nbsp;</p><hr /><p>&nbsp;</p><h3><a name='header-n2010' class='md-header-anchor '></a>9.2 lsblk</h3><p>lsblk 命令的英文是 list block，即用于列出所有可用块设备的信息，而且还能显示他们之间的依赖关系，但是不会列出 RAM 盘的信息</p><p>命令：lsblk [参数]</p><ul><li><p><code>lsblk</code>：以树状列出所有块设备
<img src='https://img-blog.csdnimg.cn/5dc4c63c85d54647a7dae8e9f196590a.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p>NAME：这是块设备名</p><p>MAJ：MIN : 本栏显示主要和次要设备号</p><p>RM：本栏显示设备是否可移动设备，在上面设备 sr0 的 RM 值等于 1，这说明他们是可移动设备</p><p>SIZE：本栏列出设备的容量大小信息</p><p>RO：该项表明设备是否为只读，在本案例中，所有设备的 RO 值为 0，表明他们不是只读的</p><p>TYPE：本栏显示块设备是否是磁盘或磁盘上的一个分区。在本例中，sda 和 sdb 是磁盘，而 sr0 是只读存储（rom）。</p><p>MOUNTPOINT：本栏指出设备挂载的挂载点。</p><p>&nbsp;</p></li><li><p><code>lsblk -f</code>：不会列出所有空设备
<img src='https://img-blog.csdnimg.cn/f642c9a9a27d4808a04f4cd3dcad5603.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p>NAME表示设备名称</p><p>FSTYPE表示文件类型</p><p>LABEL表示设备标签</p><p>UUID设备编号</p><p>MOUNTPOINT表示设备的挂载点</p></li></ul><p>&nbsp;</p><hr /><p>&nbsp;</p><h3><a name='header-n2034' class='md-header-anchor '></a>9.3 df</h3><p> df 命令用于显示目前在 Linux 系统上的文件系统的磁盘使用情况统计。</p><p>命令：df [options]... [FILE]...</p><ul><li>-h 使用人类可读的格式(预设值是不加这个选项的...)</li><li>--total 计算所有的数据之和</li></ul><p><img src='https://img-blog.csdnimg.cn/d5870a5172df43a98e6d517ecb798c34.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p>第一列指定文件系统的名称；第二列指定一个特定的文件系统，1K 是 1024 字节为单位的总容量；已用和可用列分别指定的容量；最后一个已用列指定使用的容量的百分比；最后一栏指定的文件系统的挂载点</p><p>&nbsp;</p><hr /><p>&nbsp;</p><h3><a name='header-n2047' class='md-header-anchor '></a>9.4 mount</h3><p>mount 命令是经常会使用到的命令，它用于挂载 Linux 系统外的文件</p><p>使用者权限：所有用户，设置级别的需要管理员</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sh" contenteditable="false" cid="n2050" mdtype="fences">mount [-hV]
mount -a [-fFnrsvw] [-t vfstype]
mount [-fnrsvw] [-o options [,...]] device | dir
mount [-fnrsvw] [-t vfstype] [-o options] device dir
</pre><ul><li>-t：指定档案系统的型态，通常不必指定。mount 会自动选择正确的型态。</li></ul><p>通过挂载的方式查看 Linux CD/DVD 光驱，查看 ubuntu-20.04.1-desktop-amd64.iso 的文件</p><ul><li><p>进入【虚拟机】--【设置】，设置 CD/DVD 的内容，ubuntu-20.04.1-desktop-amd64.iso</p></li><li><p>创建挂载点（注意：一般用户无法挂载 cdrom，只有 root 用户才可以操作）</p><p><code>mkdir -p /mnt/cdrom</code>：切换到 root 下创建一个挂载点（其实就是创建一个目录）</p></li><li><p>开始挂载
<code>mount -t auto /dev/cdrom /mnt/cdrom</code>：通过挂载点的方式查看上面的【ISO文件内容】
<img src='https://img-blog.csdnimg.cn/7d7d9def1b2447be8c8f52bc59331c5b.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p></li><li><p>查看挂载内容：<code>ls -l -a ./mnt/cdrom/</code></p></li><li><p>卸载 cdrom：<code>umount /mnt/cdrom/</code></p></li></ul><p>&nbsp;</p><p>&nbsp;</p><hr /><p>&nbsp;</p><p>&nbsp;</p><h2><a name='header-n2072' class='md-header-anchor '></a>10. 防火墙</h2><h3><a name='header-n2073' class='md-header-anchor '></a>10.1 概述</h3><p>防火墙技术是通过有机结合各类用于安全管理与筛选的软件和硬件设备，帮助计算机网络于其内、外网之间构建一道相对隔绝的保护屏障，以保护用户资料与信息安全性的一种技术。在默认情况下，Linux 系统的防火墙状态是打开的</p><p>&nbsp;</p><h3><a name='header-n2076' class='md-header-anchor '></a>10.2 状态</h3><p>启动语法：service  name status</p><ul><li>查看防火墙状态：<code>service iptables status</code></li><li>临时开启：<code>service iptables start</code></li><li>临时关闭：<code>service iptables stop</code></li><li>开机启动：<code>chkconfig iptables on</code></li><li>开机关闭：<code>chkconfig iptables off</code></li></ul><p>&nbsp;</p><h3><a name='header-n2090' class='md-header-anchor '></a>10.3 放行</h3><p>设置端口防火墙放行</p><ul><li>修改配置文件：<code>vim /etc/sysconfig/iptables</code></li><li>添加放行端口：<code>-A INPUT -m state --state NEW -m tcp -p tcp --dport 端口号 -j ACCEPT</code></li><li>重新加载防火墙规则：<code>service iptables reload</code></li></ul><p>备注：默认情况下 22 端口号是放行的</p><p>&nbsp;</p><p>&nbsp;</p><hr /><p>&nbsp;</p><p>&nbsp;</p><h2><a name='header-n2105' class='md-header-anchor '></a>11. Shell</h2><h3><a name='header-n2106' class='md-header-anchor '></a>11.1 入门</h3><h4><a name='header-n2107' class='md-header-anchor '></a>11.1.1 概念</h4><p>Shell 脚本（shell script），是一种为 shell 编写的脚本程序，又称 Shell 命令稿、程序化脚本，是一种计算机程序使用的文本文件，内容由一连串的 shell 命令组成，经由 Unix Shell 直译其内容后运作</p><p>Shell 被当成是一种脚本语言来设计，其运作方式与解释型语言相当，由 Unix shell 扮演命令行解释器的角色，在读取 shell 脚本之后，依序运行其中的 shell 命令，之后输出结果</p><p>&nbsp;</p><h4><a name='header-n2111' class='md-header-anchor '></a>11.1.2 环境</h4><p>Shell 编程跟 JavaScript、php 编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。</p><p><code>cat /etc/shells</code>：查看解释器
<img src='https://img-blog.csdnimg.cn/3056cdb933fa4030b1742ded63e0f6f2.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p>Linux 的 Shell 种类众多，常见的有：</p><ul><li>Bourne Shell（/usr/bin/sh或/bin/sh）</li><li>Bourne Again Shell（/bin/bash）：Bash 是大多数Linux 系统默认的 Shell</li><li>C Shell（/usr/bin/csh）</li><li>K Shell（/usr/bin/ksh）</li><li>Shell for Root（/sbin/sh）</li><li>等等……</li></ul><p>&nbsp;</p><h4><a name='header-n2129' class='md-header-anchor '></a>11.1.3 第一个shell</h4><ul><li><p>新建 s.sh 文件：touch s.sh</p></li><li><p>编辑 s.sh 文件：vim s.sh</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="shell" contenteditable="false" cid="n2135" mdtype="fences">#!/bin/bash  --- 指定脚本解释器
echo "你好，shell !"   ---向窗口输入文本

:&lt;&lt;!
写shell的习惯 第一行指定解释器
文件是sh为后缀名
括号成对书写
注释的时候尽量不用中文注释。不友好。
[] 括号两端要要有空格。  [ neirong ]
习惯代码索引，增加阅读性
写语句的时候，尽量写全了，比如if。。。
!
</pre></li><li><p>查看 s.sh文件：ls -l    s.sh文件权限是【-rw-rw-r--】</p></li><li><p>chmod a+x s.sh         s.sh文件权限是【-rwxrwxr-x】</p></li><li><p>执行文件：./s.sh</p></li><li><p>或者直接  <code>bash s.sh</code></p></li></ul><p><strong>注意：</strong></p><p><strong>#!</strong> 是一个约定的标记，告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell</p><p>echo 命令用于向窗口输出文本</p><p>&nbsp;</p><hr /><p>&nbsp;</p><h3><a name='header-n2150' class='md-header-anchor '></a>11.2 注释</h3><ul><li><p>单行注释：以 <strong>#</strong> 开头的行就是注释，会被解释器忽略</p></li><li><p>多行注释：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="shell" contenteditable="false" cid="n2156" mdtype="fences">:&lt;&lt;EOF
注释内容...
注释内容...
EOF
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="shell" contenteditable="false" cid="n2157" mdtype="fences">:&lt;&lt;!      -----这里的符号要和结尾处的一样
注释内容...
注释内容...
注释内容...
!        
</pre></li></ul><p>&nbsp;</p><hr /><p>&nbsp;</p><h3><a name='header-n2161' class='md-header-anchor '></a>11.3 变量</h3><h4><a name='header-n2162' class='md-header-anchor '></a>11.3.1 定义变量</h4><p>变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。同时，变量名的命名须遵循如下规则：</p><ul><li>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。</li><li>中间不能有空格，可以使用下划线（_）。</li><li>不能使用标点符号。</li><li>不能使用bash里的关键字（可用help命令查看保留关键字）。</li></ul><p>&nbsp;</p><p>  </p><h4><a name='header-n2175' class='md-header-anchor '></a>11.3.2 使用变量</h4><p> 使用一个定义过的变量，只要在变量名前面加美元符号$即可</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="shell" contenteditable="false" cid="n2177" mdtype="fences">name="seazean"
echo $name
echo ${name}
name="zhy"
</pre><ul><li><p>已定义的变量，可以被重新定义变量名</p></li><li><p>外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界。推荐加！！</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sh" contenteditable="false" cid="n2183" mdtype="fences">比如：echo "I am good at ${shell-t}Script"
通过上面的脚本我们发现，如果不给shell-t变量加花括号，写成echo "I am good at $shell-tScript"，解释器shell就会把$shell-tScript当成一个变量，由于我们前面没有定义shell-t变量，那么解释器执行执行的结果自然就为空了。
</pre><p>&nbsp;</p></li></ul><p>&nbsp;</p><h4><a name='header-n2186' class='md-header-anchor '></a>11.3.3 只读变量</h4><p>使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。(类似于final)</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="shell" contenteditable="false" cid="n2188" mdtype="fences">#!/bin/bash
myUrl="https://www.baidu.com"
readonly myUrl
myUrl="https://cn.bing.com/"  
#报错 myUrl readonly
</pre><p>&nbsp;</p><h4><a name='header-n2190' class='md-header-anchor '></a>11.3.4 删除变量</h4><p>使用 unset 命令可以删除变量，变量被删除后不能再次使用。</p><p>语法：<code>unset variable_name</code></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="shell" contenteditable="false" cid="n2193" mdtype="fences">#!/bin/sh
myUrl="https://www.baidu.com"
unset myUrl
echo $myUrl
</pre><p>定义myUrl变量，通过unset删除变量，然后通过echo进行输出，<strong>结果是为空</strong>，没有任何的结果输出。</p><p>  </p><h4><a name='header-n2196' class='md-header-anchor '></a>11.3.5 字符变量</h4><blockquote><p>字符串是shell编程中最常用也是最有用的数据类型，字符串可以用单引号，也可以用双引号，也可以不用引号，在Java SE中我们定义一个字符串通过Stirng  s=“abc&quot; 双引号的形式进行定义，而在shell中也是可以的。</p></blockquote><h5><a name='header-n2199' class='md-header-anchor '></a>11.3.5.1 引号</h5><ul><li><p><strong>单引号</strong></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sh" contenteditable="false" cid="n2203" mdtype="fences">str='this is a string variable'
</pre><p>单引号字符串的限制：</p><ul><li>单引号里的任何字符都会原样输出，单引号字符串中的<strong>变量是无效的</strong>；</li><li>单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。</li></ul></li><li><p>双引号</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="shell" contenteditable="false" cid="n2212" mdtype="fences">your_name='frank'
str="Hello,\"$your_name\"! \n"
echo -e $str     #Hello, "frank"!
</pre><p>双引号的优点：</p><ul><li>双引号里可以有变量</li><li>双引号里可以出现转义字符</li></ul></li></ul><p>&nbsp;</p><h5><a name='header-n2220' class='md-header-anchor '></a>11.3.5.2 拼接字符串</h5><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="shell" contenteditable="false" cid="n2221" mdtype="fences">your_name="frank"
# 使用双引号拼接
greeting="hello, "$your_name" !"
greeting_1="hello, ${your_name} !"
echo $greeting  $greeting_1
#hello,frank! hello,frank
</pre><p>&nbsp;</p><h5><a name='header-n2223' class='md-header-anchor '></a>11.3.5.3 获取字符串长度</h5><p>命令：<code>${#variable_name}</code></p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sh" contenteditable="false" cid="n2225" mdtype="fences">string="seazean"
echo ${#string} #7
</pre><p>&nbsp;</p><h5><a name='header-n2227' class='md-header-anchor '></a>11.3.5.4 提取字符串</h5><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="shell" contenteditable="false" cid="n2228" mdtype="fences">string="abcdefghijklmn"
echo ${string:1:4} 
</pre><p>输出为【bcde】，通过截取我们发现，它的下标和我们在java中的读取方式是一样的，下标也是从0开始。</p><p>&nbsp;</p><hr /><p>&nbsp;</p><h3><a name='header-n2233' class='md-header-anchor '></a>11.4 数组</h3><p>bash支持一维数组（不支持多维数组），并且没有限定数组的大小。</p><h4><a name='header-n2235' class='md-header-anchor '></a>11.4.1 定义数组</h4><p>在 Shell 中，用括号来表示数组，数组元素用&quot;空格&quot;符号分割开</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="shell" contenteditable="false" cid="n2237" mdtype="fences">数组名=(值1 值2 ... 值n)
array_name=(value0 value1 value2 value3) 
array_name=(
value0
value1
value2
value3
)
</pre><p>通过下标定义数组中的其中一个元素：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="shell" contenteditable="false" cid="n2239" mdtype="fences">array_name[0]=value0
array_name[1]=value1
array_name[n]=valuen
</pre><p>可以不使用连续的下标，而且下标的范围没有限制</p><p>&nbsp;</p><h4><a name='header-n2242' class='md-header-anchor '></a>11.4.2 读取数组</h4><p>读取数组元素值的一般格式是：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sh" contenteditable="false" cid="n2244" mdtype="fences">${数组名[下标]}

value=${array_name[n]}
echo ${value}
</pre><p>使用 <strong>@</strong> 符号可以获取数组中的所有元素，例如：<code>echo ${array_name[@]}</code></p><p>&nbsp;</p><h4><a name='header-n2247' class='md-header-anchor '></a>11.4.3 获取长度</h4><p>获取数组长度的方法与获取字符串长度的方法相同，数组前加#</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sh" contenteditable="false" cid="n2249" mdtype="fences"># 取得数组元素的个数
length=${#array_name[@]}
# 或者
length=${#array_name[*]}
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sh" contenteditable="false" cid="n2250" mdtype="fences">#! /bin/bash
g=(a b c d e f)
echo "数组下标为2的数据为:" ${g[2]}  #c
echo  "数组所有数据为:"  ${#g[@]}   #6
echo  "数组所有数据为:"   ${#g[*]}  #6
</pre><p>&nbsp;</p><hr /><p>&nbsp;</p><h3><a name='header-n2254' class='md-header-anchor '></a>11.5 运算符</h3><p>Shell 和其他编程一样，<strong>支持</strong>包括：算术、关系、布尔、字符串等运算符。原生 bash <strong>不支持 </strong>简单的数学运算，但是可以通过其他命令来实现，例如expr。expr 是一款表达式计算工具，使用它能完成表达式的求值操作。</p><h4><a name='header-n2256' class='md-header-anchor '></a>11.5.1 规则</h4><ul><li><strong>表达式和运算符之间要有空格</strong>，例如 2+2 是不对的，必须写成 2 + 2</li><li><strong>完整的表达式要被 `` 包含，注意不是单引号</strong></li><li><strong>条件表达式要放在方括号之间，并且要有空格</strong>，例如: <code>[$a==$b]</code> 是错误的，必须写成 <code>[ $a == $b ]</code></li><li><strong>(())双括号里可以跟表达式</strong>，例如((i++))，((a+b))</li></ul><p>&nbsp;</p><h4><a name='header-n2267' class='md-header-anchor '></a>11.5.2 算术运算符</h4><figure><table><thead><tr><th><strong>运算符</strong></th><th><strong>说明</strong></th><th><strong>举例</strong></th></tr></thead><tbody><tr><td>+</td><td>加法</td><td><code>expr $a + $b</code> 结果为 30。</td></tr><tr><td>-</td><td>减法</td><td><code>expr $a - $b</code> 结果为 -10。</td></tr><tr><td>*</td><td>乘法</td><td><code>expr $a \* $b</code> 结果为  200。</td></tr><tr><td>/</td><td>除法</td><td><code>expr $b / $a</code> 结果为 2。</td></tr><tr><td>%</td><td>取余</td><td><code>expr $b % $a</code> 结果为 0。</td></tr><tr><td>=</td><td>赋值</td><td>a=$b 将把变量 b 的值赋给 a。</td></tr><tr><td>==</td><td>相等。用于比较两个数字，相同则返回 true。</td><td><code>[ $a == $b ]</code>返回 false。</td></tr><tr><td>!=</td><td>不相等。用于比较两个数字，不相同则返回 true。</td><td><code>[ $a != $b ]</code>返回 true。</td></tr></tbody></table></figure><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="shell" contenteditable="false" cid="n2305" mdtype="fences">#! /bin/bash
a=4
b=20
echo "加法运算"  `expr $a + $b` 
echo "乘法运算，注意*号前面需要反斜杠" ` expr $a \* $b`
echo "加法运算"  `expr  $b / $a`
((a++))
echo "a = $a"
c=$((a + b)) 
d=$[a + b]
echo "c = $c"
echo "d = $d"
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="" contenteditable="false" cid="n2306" mdtype="fences">//结果
加法运算 24
减法运算 -16
乘法运算，注意*号前面需要反斜杠 80
加法运算 5
a = 5
c = 25
d = 25
</pre><p>&nbsp;</p><p>&nbsp;</p><h4><a name='header-n2309' class='md-header-anchor '></a>11.5.3 字符运算符</h4><p>假定变量 a 为 &quot;abc&quot;，变量 b 为 &quot;efg&quot;，true=0，false=1。</p><figure><table><thead><tr><th style='text-align:left;' >运算符</th><th style='text-align:left;' >说明</th><th style='text-align:left;' >举例</th></tr></thead><tbody><tr><td style='text-align:left;' >=</td><td style='text-align:left;' >检测两个字符串是否相等，相等返回 true。</td><td style='text-align:left;' ><code>[ $a = $b ]</code> 返回 false。</td></tr><tr><td style='text-align:left;' >!=</td><td style='text-align:left;' >检测两个字符串是否相等，不相等返回 true。</td><td style='text-align:left;' ><code>[ $a != $b ]</code> 返回 true。</td></tr><tr><td style='text-align:left;' >-z</td><td style='text-align:left;' >检测字符串长度是否为0，为0返回 true。</td><td style='text-align:left;' ><code>[ -z $a ]</code> 返回 false。</td></tr><tr><td style='text-align:left;' >-n</td><td style='text-align:left;' >检测字符串长度是否为0，不为0返回 true。</td><td style='text-align:left;' ><code>[ -n &quot;$a&quot; ]</code> 返回 true。</td></tr><tr><td style='text-align:left;' >$</td><td style='text-align:left;' >检测字符串是否为空，不为空返回 true。</td><td style='text-align:left;' ><code>[ $a ]</code> 返回 true。</td></tr></tbody></table></figure><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="shell" contenteditable="false" cid="n2336" mdtype="fences" style="break-inside: unset;">a="abc"
b="efg"

if [ $a = $b ]
then
   echo "$a = $b : a 等于 b"
else
   echo "$a = $b: a 不等于 b"
fi
if [ $a != $b ]
then
   echo "$a != $b : a 不等于 b"
else
   echo "$a != $b: a 等于 b"
fi
</pre><p>&nbsp;</p><p>&nbsp;</p><h4><a name='header-n2339' class='md-header-anchor '></a>11.5.4 关系运算符</h4><p>关系运算符只支持数字，不支持字符串，除非字符串的值是数字。</p><p>下表列出了常用的关系运算符，假定变量 a 为 10，变量 b 为 20：</p><figure><table><thead><tr><th style='text-align:left;' >运算符</th><th style='text-align:left;' >说明</th><th style='text-align:left;' >举例</th></tr></thead><tbody><tr><td style='text-align:left;' >-eq</td><td style='text-align:left;' >检测两个数是否相等，相等返回 true。</td><td style='text-align:left;' ><code>[ $a -eq $b ]</code> 返回 false。</td></tr><tr><td style='text-align:left;' >-ne</td><td style='text-align:left;' >检测两个数是否不相等，不相等返回 true。</td><td style='text-align:left;' ><code>[ $a -ne $b ]</code> 返回 true。</td></tr><tr><td style='text-align:left;' >-gt</td><td style='text-align:left;' >检测左边的数是否大于右边的，如果是，则返回 true。</td><td style='text-align:left;' ><code>[ $a -gt $b ]</code> 返回 false。</td></tr><tr><td style='text-align:left;' >-lt</td><td style='text-align:left;' >检测左边的数是否小于右边的，如果是，则返回 true。</td><td style='text-align:left;' ><code>[ $a -lt $b ]</code> 返回 true。</td></tr><tr><td style='text-align:left;' >-ge</td><td style='text-align:left;' >检测左边的数是否大于等于右边的，如果是，则返回 true。</td><td style='text-align:left;' ><code>[ $a -ge $b ]</code> 返回 false。</td></tr><tr><td style='text-align:left;' >-le</td><td style='text-align:left;' >检测左边的数是否小于等于右边的，如果是，则返回 true。</td><td style='text-align:left;' ><code>[ $a -le $b ]</code> 返回 true。</td></tr></tbody></table></figure><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sh" contenteditable="false" cid="n2371" mdtype="fences">a=10
b=20

if [ $a -eq $b ]
then
   echo "$a -eq $b : a 等于 b"
else
   echo "$a -eq $b: a 不等于 b"
fi
</pre><p>&nbsp;</p><p>&nbsp;</p><h4><a name='header-n2374' class='md-header-anchor '></a>11.5.5 布尔运算符</h4><p>下表列出了常用的布尔运算符，假定变量 a 为 10，变量 b 为 20：</p><figure><table><thead><tr><th style='text-align:left;' >运算符</th><th style='text-align:left;' >说明</th><th style='text-align:left;' >举例</th></tr></thead><tbody><tr><td style='text-align:left;' >!</td><td style='text-align:left;' >非运算，表达式为 true 则返回 false，否则返回 true。</td><td style='text-align:left;' >[ ! false ] 返回 true。</td></tr><tr><td style='text-align:left;' >-o</td><td style='text-align:left;' >或运算，有一个表达式为 true 则返回 true。</td><td style='text-align:left;' ><code>[ $a -lt 20 -o $b -gt 100 ]</code>true</td></tr><tr><td style='text-align:left;' >-a</td><td style='text-align:left;' >与运算，两个表达式都为 true 才返回 true。</td><td style='text-align:left;' ><code>[ $a -lt 20 -a $b -gt 100 ]</code>false</td></tr></tbody></table></figure><p>&nbsp;</p><h4><a name='header-n2394' class='md-header-anchor '></a>11.5.6 逻辑运算符</h4><p>假定变量 a 为 10，变量 b 为 20:</p><figure><table><thead><tr><th style='text-align:left;' >运算符</th><th style='text-align:left;' >说明</th><th style='text-align:left;' >举例</th></tr></thead><tbody><tr><td style='text-align:left;' >&amp;&amp;</td><td style='text-align:left;' >逻辑的 AND</td><td style='text-align:left;' ><code>[[ $a -lt 100 &amp;&amp; $b -gt 100 ]]</code> 返回 false</td></tr><tr><td style='text-align:left;' >||</td><td style='text-align:left;' >逻辑的 OR</td><td style='text-align:left;' ><code>[[ $a -lt 100 \|\| $b -gt 100 ]]</code> 返回 true</td></tr></tbody></table></figure><p>&nbsp;</p><hr /><p>&nbsp;</p><h3><a name='header-n2412' class='md-header-anchor '></a>11.6 流程控制</h3><h4><a name='header-n2413' class='md-header-anchor '></a>11.6.1 if</h4><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="shell" contenteditable="false" cid="n2414" mdtype="fences">if condition
then
    command1 
    command2
    ...
    commandN 
fi
#末尾的fi就是if倒过来拼写
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="shell" contenteditable="false" cid="n2415" mdtype="fences">if condition
then
    command1 
    command2
    ...
    commandN
else
    command
fi
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="shell" contenteditable="false" cid="n2416" mdtype="fences">if condition1
then
    command1
elif condition2 
then 
    command2
else
    commandN
fi
</pre><ul><li><p>查找一个进程，如果进程存在就打印true</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="shell" contenteditable="false" cid="n2420" mdtype="fences">if [ $(ps -ef | grep -c "ssh") -gt 1 ]]
then 
	echo "true"
fi
</pre></li><li><p>判断两个变量是否相等</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="shell" contenteditable="false" cid="n2423" mdtype="fences" style="break-inside: unset;">a=10
b=20
if [ $a == $b ]
then
   echo "a 等于 b"
elif [ $a -gt $b ]
then
   echo "a 大于 b"
elif [ $a -lt $b ]
then
   echo "a 小于 b"
else
   echo "没有符合的条件"
fi
</pre><p>&nbsp;</p></li></ul><p>&nbsp;</p><h4><a name='header-n2426' class='md-header-anchor '></a>11.6.2 for</h4><p>for循环格式为：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="shell" contenteditable="false" cid="n2428" mdtype="fences">for var in item1 item2 ... itemN
do
    command1
    command2
    ...
    commandN
done
</pre><p>顺序输出当前列表中的字母：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="shell" contenteditable="false" cid="n2430" mdtype="fences">for loop in A B C D E F G 
do
    echo "顺序输出字母为: $loop"
done

顺序输出字母为:A
顺序输出字母为:B
....
顺序输出字母为:G
</pre><p>&nbsp;</p><h4><a name='header-n2432' class='md-header-anchor '></a>11.6.3 while</h4><p>while循环用于不断执行一系列命令，也用于从输入文件中读取数据 </p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="shell" contenteditable="false" cid="n2434" mdtype="fences">while condition
do
    command
done
</pre><p>需求：如果int小于等于10，那么条件返回真。int从0开始，每次循环处理时，int加1。 </p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="shell" contenteditable="false" cid="n2436" mdtype="fences">#!/bin/bash
a=1
while [ "${a}" -le 10 ]
do
    echo "输出的值为：" $a
    ((a++))
done
输出的值为：1
输出的值为：2
...
输出的值为：10
</pre><p>&nbsp;</p><h4><a name='header-n2438' class='md-header-anchor '></a>11.6.4 case...esac</h4><p>与 switch ... case 语句类似，是一种多分枝选择结构，每个 case 分支用右圆括号开始，用两个分号 <strong>;;</strong> 表示 break，即执行结束，跳出整个 case ... esac 语句，esac（就是 case 反过来）作为结束标记。</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="shell" contenteditable="false" cid="n2440" mdtype="fences" style="break-inside: unset;">case 值 in  
模式1)
    command1
    command2
    command3
    ;;
模式2）
    command1
    command2
    command3
    ;;
*)
    command1
    command2
    command3
    ;;
esac  #case反过来
</pre><ul><li>case 后为取值，值可以为变量或常数。</li><li>值后为关键字 in，接下来是匹配的各种模式，每一模式最后必须以右括号结束，模式支持正则表达式。</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="shell" contenteditable="false" cid="n2446" mdtype="fences">v="czbk"

case "$v" in
"czbk") 
	echo "传智播客"
   	;;
"baidu") 
	echo "baidu 搜索"
	;;
"google") 
	echo "google 搜索"
   	;;
esac
</pre><p>&nbsp;</p><p>&nbsp;</p><hr /><p>&nbsp;</p><h3><a name='header-n2451' class='md-header-anchor '></a>11.7 函数</h3><h4><a name='header-n2452' class='md-header-anchor '></a>11.7.1 输入</h4><p>函数语法如下：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="shell" contenteditable="false" cid="n2454" mdtype="fences">[ function ] funname [()]
{
    action;
    [return int;]

}
</pre><ul><li>1、可以使用function fun() 定义函数，也可以直接fun() 定义,不带任何参数。</li><li>2、函数参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255</li></ul><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="shell" contenteditable="false" cid="n2460" mdtype="fences" style="break-inside: unset;">#无参无返回值的方法
method(){
	echo "函数执行了!"
}

#方法的调用
#method



#有参无返回值的方法
method2(){
	echo "接收到的第一个参数$1"
	echo "接收到的第二个参数$2"
}

#方法的调用
#method2 1 2

#有参有返回值方法的定义
method3(){
	echo "接收到的第一个参数$1"
	echo "接收到的第二个参数$2"
	return $(($1 + $2))
}

#方法的调用
method3 10 20
echo $?
</pre><p>&nbsp;</p><h4><a name='header-n2462' class='md-header-anchor '></a>11.7.2 读取</h4><p><code>read 变量名</code> --- 表示把键盘录入的数据复制给这个变量</p><p>需求：在方法中键盘录入两个整数,返回这两个整数的和</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="shell" contenteditable="false" cid="n2465" mdtype="fences">method(){
	echo "请录入第一个数"
	read number1
	echo "请录入第二个数"
	read number2
	echo "两个数字分别为${number1},${number2}"
	return $((number1+number2))
}

method
echo $?
</pre><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr /><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h1><a name='header-n2473' class='md-header-anchor '></a>三、Docker</h1><h2><a name='header-n2474' class='md-header-anchor '></a>1. 基本概述</h2><p>Docker 是一个开源的应用容器引擎，诞生于 2013 年初，基于 Go 语言实现， dotCloud 公司出品</p><p>Docker 让开发者打包开发应用以及依赖包到一个轻量级、可移植的容器中，可以发布到任何Linux机器上</p><ul><li>容器是完全使用沙箱机制，相互隔离</li><li>容器性能开销极低。</li></ul><p>Docker 架构：</p><ul><li><strong>镜像（Image）：</strong>Docker 镜像，就相当于一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统</li><li><strong>容器（Container）</strong>：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和对象一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等</li><li><strong>仓库（Repository）</strong>：仓库可看成一个代码控制中心，用来保存镜像</li></ul><p><img src='https://img-blog.csdnimg.cn/79c64b342acc422bbd517a29ea487080.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p>安装步骤：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sh" contenteditable="false" cid="n2492" mdtype="fences"># step 1: 安装必要的一些系统工具
sudo apt-get update
sudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common
# step 2: 安装GPG证书
curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -
# Step 3: 写入软件源信息
sudo add-apt-repository "deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable"
# Step 4: 更新并安装Docker-CE
sudo apt-get -y update
sudo apt-get -y install docker-ce
</pre><p>配置镜像加速器：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sh" contenteditable="false" cid="n2494" mdtype="fences">sudo mkdir -p /etc/docker
sudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'
{
  "registry-mirrors": ["https://hicqe4pi.mirror.aliyuncs.com"]
}
EOF
sudo systemctl daemon-reload
sudo systemctl restart docker
</pre><p>&nbsp;</p><p>&nbsp;</p><hr /><p>&nbsp;</p><h2><a name='header-n2499' class='md-header-anchor '></a>2. 操作命令</h2><h3><a name='header-n2500' class='md-header-anchor '></a>2.1 进程相关</h3><ul><li><p>启动docker服务：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sh" contenteditable="false" cid="n2504" mdtype="fences">systemctl start docker
</pre></li><li><p>停止docker服务：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sh" contenteditable="false" cid="n2507" mdtype="fences">systemctl stop docker
</pre></li><li><p>重启doker服务：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sh" contenteditable="false" cid="n2510" mdtype="fences">systemctl restart docker
</pre></li><li><p>查看doker服务状态：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sh" contenteditable="false" cid="n2513" mdtype="fences">systemctl status docker
</pre></li><li><p>设置开机启动docker服务：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sh" contenteditable="false" cid="n2516" mdtype="fences">systemctl enable docker
</pre><p>&nbsp;</p></li></ul><p>&nbsp;</p><h3><a name='header-n2519' class='md-header-anchor '></a>2.2 镜像相关</h3><ul><li><p>查看镜像：查看本地所有的镜像</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sh" contenteditable="false" cid="n2523" mdtype="fences">docker images
docker images –q # 查看所用镜像的id
</pre></li><li><p>搜索镜像：从网络中查找需要的镜像</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sh" contenteditable="false" cid="n2526" mdtype="fences">docker search 镜像名称
</pre></li><li><p>拉取镜像：从Docker仓库下载镜像到本地，镜像名称格式为 名称:版本号，如果版本号不指定则是最新的版本。如果不知道镜像版本，可以去docker hub 搜索对应镜像查看</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sh" contenteditable="false" cid="n2529" mdtype="fences">docker pull 镜像名称
</pre></li><li><p>删除镜像：删除本地镜像</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sh" contenteditable="false" cid="n2532" mdtype="fences">docker rmi 镜像id # 删除指定本地镜像
docker rmi `docker images -q`  # 删除所有本地镜像 tab上面的键
</pre></li></ul><p>&nbsp;</p><p>&nbsp;</p><h3><a name='header-n2535' class='md-header-anchor '></a>2.3 容器相关</h3><ul><li><p>查看容器：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sh" contenteditable="false" cid="n2539" mdtype="fences">docker ps # 查看正在运行的容器
docker ps –a # 查看所有容器
</pre></li><li><p>创建并启动容器：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sh" contenteditable="false" cid="n2542" mdtype="fences">docker run 参数  --name=... /bin/bash
</pre><p>参数说明：</p><ul><li>-i：保持容器运行，通常与 -t 同时使用，加入it这两个参数后，容器创建后自动进入容器中，退出容器后，容器自动关闭</li><li>-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用</li><li>-d：以守护（后台）模式运行容器。创建一个容器在后台运行，需要使用docker exec 进入容器。退出后，容器不会关闭</li><li><strong>-it 创建的容器一般称为交互式容器，-id 创建的容器一般称为守护式容器</strong></li><li><strong>--name：为创建的容器命名</strong></li></ul></li><li><p>进入容器：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sh" contenteditable="false" cid="n2557" mdtype="fences">docker exec 参数 # 退出容器，容器不会关闭
</pre></li><li><p>停止容器：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sh" contenteditable="false" cid="n2560" mdtype="fences">docker stop 容器名称
</pre></li><li><p>启动容器：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sh" contenteditable="false" cid="n2563" mdtype="fences">docker start 容器名称
</pre></li><li><p>删除容器：如果容器是运行状态则删除失败，需要停止容器才能删除</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sh" contenteditable="false" cid="n2566" mdtype="fences">docker rm 容器名称
</pre></li><li><p>查看容器信息：</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sh" contenteditable="false" cid="n2569" mdtype="fences">docker inspect 容器名称
</pre><p>&nbsp;</p></li></ul><p>&nbsp;</p><hr /><p>&nbsp;</p><h2><a name='header-n2574' class='md-header-anchor '></a>3. 数据卷</h2><blockquote><p>Docker 容器删除后，在容器中产生的数据也会随之销毁
Docker 容器和外部机器可以直接交换文件吗？
容器之间想要进行数据交互？</p></blockquote><p>&lt;img src=&quot;https:<img src='https://img-blog.csdnimg.cn/6eadf8e427084456a717f7525b2660b6.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p><strong>数据卷</strong>：数据卷是宿主机中的一个目录或文件，当容器目录和数据卷目录绑定后，对方的修改会立即同步</p><ul><li>一个数据卷可以被多个容器同时挂载</li><li>一个容器也可以被挂载多个数据卷</li></ul><p>数据卷的作用：</p><ul><li>容器数据持久化</li><li>外部机器和容器间接通信</li><li>容器之间数据交换</li></ul><p>配置数据卷</p><ul><li><p>创建启动容器时，使用-v参数设置数据卷</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sh" contenteditable="false" cid="n2596" mdtype="fences">docker run ... –v 宿主机目录(文件):容器内目录(文件) ... 
docker run -it --name=c1 -v /root(or~)/data:/root/data_container centos:7
</pre><p>注意事项：</p><ol start='' ><li>目录必须是绝对路径</li><li>如果目录不存在，会自动创建</li><li>可以挂载多个数据卷</li></ol></li></ul><p>多容器进行数据交换：</p><ul><li>多个容器挂载同一个数据卷</li><li>数据卷容器</li></ul><p><img src='https://img-blog.csdnimg.cn/e67f8acf67774a7eb76294427d1ef43c.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><ul><li><p>创建启动c3数据卷容器，使用 –v 参数设置数据卷</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sh" contenteditable="false" cid="n2615" mdtype="fences">docker run –it --name=c3 –v /volume centos:7 /bin/bash 
</pre></li><li><p>创建启动 c1 c2 容器，使用 –-volumes-from 参数设置数据卷</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sh" contenteditable="false" cid="n2618" mdtype="fences">docker run –it --name=c1 --volumes-from c3 centos:7 /bin/bash
docker run –it --name=c2 --volumes-from c3 centos:7 /bin/bash  
</pre></li></ul><p>&nbsp;</p><p>&nbsp;</p><hr /><p>&nbsp;</p><h2><a name='header-n2623' class='md-header-anchor '></a>4. 应用部署</h2><h3><a name='header-n2624' class='md-header-anchor '></a>4.1 MySQL</h3><p>在Docker容器中部署MySQL，通过外部mysql客户端操作MySQL Server</p><p>端口映射：</p><ul><li><p>容器内的网络服务和外部机器不能直接通信，外部机器和宿主机可以直接通信，宿主机和容器可以直接通信</p></li><li><p>当容器中的网络服务需要被外部机器访问时，可以将容器中提供服务的端口映射到宿主机的端口上。外部机器访问宿主机的该端口，从而间接访问容器的服务。这种操作称为：<strong>端口映射</strong></p><p><img src='https://img-blog.csdnimg.cn/0efac6ffc0fc4a478649bdb59c7be0a5.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p></li></ul><p>MySQL部署步骤：搜索mysql镜像，拉取mysql镜像，创建容器，操作容器中的mysql</p><ol start='' ><li><p>搜索mysql镜像</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sh" contenteditable="false" cid="n2637" mdtype="fences">docker search mysql
</pre></li><li><p>拉取mysql镜像</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="mysql" contenteditable="false" cid="n2640" mdtype="fences">docker pull mysql:5.6
</pre></li><li><p>创建容器，设置端口映射、目录映射</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sh" contenteditable="false" cid="n2643" mdtype="fences"># 在/root目录下创建mysql目录用于存储mysql数据信息
mkdir ~/mysql
cd ~/mysql
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sh" contenteditable="false" cid="n2644" mdtype="fences">docker run -id \
-p 3307:3306 \
--name=c_mysql \
-v $PWD/conf:/etc/mysql/conf.d \
-v $PWD/logs:/logs \
-v $PWD/data:/var/lib/mysql \
-e MYSQL_ROOT_PASSWORD=123456 \
mysql:5.6
</pre><p>参数说明：</p><ul><li><code>-p 3307:3306</code>：将容器的 3306 端口映射到宿主机的 3307 端口</li><li><code>-v $PWD/conf:/etc/mysql/conf.d</code>：将主机当前目录下的 conf/my.cnf 挂载到容器的 /etc/mysql/my.cnf，配置目录</li><li><code>-v $PWD/logs:/logs</code>：将主机当前目录下的 logs目录挂载到容器的 /logs，日志目录</li><li><code>-v $PWD/data:/var/lib/mysql</code> ：将主机当前目录下的data目录挂载到容器的 /var/lib/mysql 。数据目录</li><li><code>-e MYSQL_ROOT_PASSWORD=123456</code><strong>：</strong>初始化 root 用户的密码。</li></ul></li><li><p>进入容器，操作mysql</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sh" contenteditable="false" cid="n2659" mdtype="fences">docker exec –it c_mysql /bin/bash
</pre></li><li><p>使用外部机器连接容器中的mysql</p></li></ol><p>&nbsp;</p><hr /><p>&nbsp;</p><h3><a name='header-n2665' class='md-header-anchor '></a>4.2 Tomcat</h3><ol start='' ><li><p>搜索tomcat镜像</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sh" contenteditable="false" cid="n2669" mdtype="fences">docker search tomcat
</pre></li><li><p>拉取tomcat镜像</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sh" contenteditable="false" cid="n2672" mdtype="fences">docker pull tomcat
</pre></li><li><p>创建容器，设置端口映射、目录映射</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sh" contenteditable="false" cid="n2675" mdtype="fences"># 在/root目录下创建tomcat目录用于存储tomcat数据信息
mkdir ~/tomcat
cd ~/tomcat
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sh" contenteditable="false" cid="n2676" mdtype="fences">docker run -id --name=c_tomcat \
-p 8080:8080 \
-v $PWD:/usr/local/tomcat/webapps \
tomcat 
</pre><p>参数说明：</p><ul><li><code>-p 8080:8080</code>：将容器的8080端口映射到主机的8080端口</li><li><code>-v $PWD:/usr/local/tomcat/webapps</code>：将主机中当前目录挂载到容器的webapps</li></ul></li><li><p>使用外部机器访问tomcat</p></li></ol><p>&nbsp;</p><hr /><p>&nbsp;</p><h3><a name='header-n2688' class='md-header-anchor '></a>4.3 Nginx</h3><ol start='' ><li><p>搜索nginx镜像</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sh" contenteditable="false" cid="n2692" mdtype="fences">docker search nginx
</pre></li><li><p>拉取nginx镜像</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sh" contenteditable="false" cid="n2695" mdtype="fences">docker pull nginx
</pre></li><li><p>创建容器，设置端口映射、目录映射</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sh" contenteditable="false" cid="n2698" mdtype="fences"># 在/root目录下创建nginx目录用于存储nginx数据信息
mkdir ~/nginx
cd ~/nginx
mkdir conf
cd conf
# 在~/nginx/conf/下创建nginx.conf文件,粘贴下面内容
vim nginx.conf
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sh" contenteditable="false" cid="n2699" mdtype="fences" style="break-inside: unset;">user  nginx;
worker_processes  1;

error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;


events {
    worker_connections  1024;
}


http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    access_log  /var/log/nginx/access.log  main;

    sendfile        on;
    #tcp_nopush     on;

    keepalive_timeout  65;

    #gzip  on;

    include /etc/nginx/conf.d/*.conf;
}
</pre><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sh" contenteditable="false" cid="n2700" mdtype="fences">docker run -id --name=c_nginx \
-p 80:80 \
-v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf \
-v $PWD/logs:/var/log/nginx \
-v $PWD/html:/usr/share/nginx/html \
nginx
</pre><p>参数说明：</p><ul><li><code>-p 80:80</code>：将容器的 80端口映射到宿主机的 80 端口</li><li><code>-v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf</code>：将主机当前目录下的 /conf/nginx.conf 挂载到容器的 :/etc/nginx/nginx.conf，配置目录</li><li><code>-v $PWD/logs:/var/log/nginx</code>：将主机当前目录下的 logs 目录挂载到容器的/var/log/nginx，日志目录</li></ul></li><li><p>使用外部机器访问nginx</p></li></ol><p>&nbsp;</p><hr /><p>&nbsp;</p><h3><a name='header-n2714' class='md-header-anchor '></a>4.4 Redis</h3><ol start='' ><li><p>搜索redis镜像</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sh" contenteditable="false" cid="n2718" mdtype="fences">docker search redis
</pre></li><li><p>拉取redis镜像</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sh" contenteditable="false" cid="n2721" mdtype="fences">docker pull redis:5.0
</pre></li><li><p>创建容器，设置端口映射</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sh" contenteditable="false" cid="n2724" mdtype="fences">docker run -id --name=c_redis -p 6379:6379 redis:5.0
</pre></li><li><p>使用外部机器连接redis</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sh" contenteditable="false" cid="n2727" mdtype="fences">./redis-cli.exe -h 192.168.149.135 -p 6379
</pre></li></ol><p>&nbsp;</p><p>&nbsp;</p><hr /><p>&nbsp;</p><h2><a name='header-n2732' class='md-header-anchor '></a>5. 镜像原理</h2><h3><a name='header-n2733' class='md-header-anchor '></a>5.1 底层原理</h3><blockquote><p>Docker 镜像本质是什么？
Docker 中一个centos镜像为什么只有200MB，而一个centos操作系统的iso文件要几个个G？
Docker 中一个tomcat镜像为什么有500MB，而一个tomcat安装包只有70多MB？</p></blockquote><p>操作系统的组成部分：进程调度子系统、进程通信子系统、内存管理子系统、设备管理子系统、文件管理子系统、网络通信子系统、作业控制子系统</p><p>Linux文件系统由bootfs和rootfs两部分组成：</p><ul><li>bootfs：包含bootloader（引导加载程序）和 kernel（内核）</li><li>rootfs： root文件系统，包含的就是典型 Linux 系统中的/dev，/proc，/bin，/etc等标准目录和文件</li><li>不同的linux发行版，bootfs基本一样，而rootfs不同，如ubuntu，centos</li></ul><p>Docker镜像原理：</p><ul><li>Docker镜像是一个<strong>分层文件系统</strong>，是由特殊的文件系统叠加而成，最底端是 bootfs，并复用宿主机的bootfs ，第二层是 root文件系统rootfs称为base image，然后再往上可以叠加其他的镜像文件</li><li>统一文件系统（Union File System）技术能够将不同的层整合成一个文件系统，为这些层提供了一个统一的视角，这样就隐藏了多层的存在，在用户的角度看来，只存在一个文件系统</li><li>一个镜像可以放在另一个镜像的上面。位于下面的镜像称为父镜像，最底部的镜像成为基础镜像。</li><li>当从一个镜像启动容器时，Docker会在最顶层加载一个读写文件系统作为容器</li></ul><p>问题：</p><ul><li>Docker 中一个Ubuntu镜像为什么只有200MB，而一个Ubuntu操作系统的iso文件要几个个G？
Ubuntu的iso镜像文件包含bootfs和rootfs，而docker的Ubuntu镜像复用操作系统的bootfs，只有rootfs和其他镜像层</li><li>Docker 中一个tomcat镜像为什么有500MB，而一个tomcat安装包只有70多MB？
由于docker中镜像是分层的，tomcat虽然只有70多MB，但他需要依赖于父镜像和基础镜像，所有整个对外暴露的tomcat镜像大小500多MB</li></ul><p>&nbsp;</p><hr /><p>&nbsp;</p><h3><a name='header-n2764' class='md-header-anchor '></a>5.2 镜像制作</h3><p><img src='https://img-blog.csdnimg.cn/c5d53a2bcf2f4e12b0fefce996acc63b.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><hr /><p>&nbsp;</p><h3><a name='header-n2768' class='md-header-anchor '></a>5.3 Dockerfile</h3><h4><a name='header-n2769' class='md-header-anchor '></a>5.3.1 基本概述</h4><p>Dockerfile是一个文本文件，包含一条条的指令，每一条指令构建一层，基于基础镜像最终构建出新的镜像</p><ul><li>对于开发人员：可以为开发团队提供一个完全一致的开发环境</li><li>对于测试人员：可以直接拿开发时所构建的镜像或者通过Dockerfile文件构建一个新的镜像开始工作了 </li><li>对于运维人员：在部署时，可以实现应用的无缝移植 </li></ul><p>&nbsp;</p><figure><table><thead><tr><th>关键字</th><th>作用</th><th>备注</th></tr></thead><tbody><tr><td>FROM</td><td>指定父镜像</td><td>指定dockerfile基于那个image构建</td></tr><tr><td>MAINTAINER</td><td>作者信息</td><td>用来标明这个dockerfile谁写的</td></tr><tr><td>LABEL</td><td>标签</td><td>用来标明dockerfile的标签 可以使用Label代替Maintainer 最终都是在docker image基本信息中可以查看</td></tr><tr><td>RUN</td><td>执行命令</td><td>执行一段命令 默认是/bin/sh 格式: RUN command 或者 RUN [&quot;command&quot; , &quot;param1&quot;,&quot;param2&quot;]</td></tr><tr><td>CMD</td><td>容器启动命令</td><td>提供启动容器时候的默认命令 和ENTRYPOINT配合使用.格式 CMD command param1 param2 或者 CMD [&quot;command&quot; , &quot;param1&quot;,&quot;param2&quot;]</td></tr><tr><td>ENTRYPOINT</td><td>入口</td><td>一般在制作一些执行就关闭的容器中会使用</td></tr><tr><td>COPY</td><td>复制文件</td><td>build的时候复制文件到image中</td></tr><tr><td>ADD</td><td>添加文件</td><td>build的时候添加文件到image中 不仅仅局限于当前build上下文 可以来源于远程服务</td></tr><tr><td>ENV</td><td>环境变量</td><td>指定build时候的环境变量 可以在启动的容器的时候 通过-e覆盖 格式ENV name=value</td></tr><tr><td>ARG</td><td>构建参数</td><td>构建参数 只在构建的时候使用的参数 如果有ENV 那么ENV的相同名字的值始终覆盖arg的参数</td></tr><tr><td>VOLUME</td><td>定义外部可以挂载的数据卷</td><td>指定build的image那些目录可以启动的时候挂载到文件系统中 启动容器的时候使用 -v 绑定 格式 VOLUME [&quot;目录&quot;]</td></tr><tr><td>EXPOSE</td><td>暴露端口</td><td>定义容器运行的时候监听的端口 启动容器的使用-p来绑定暴露端口 格式: EXPOSE 8080 或者 EXPOSE 8080/udp</td></tr><tr><td>WORKDIR</td><td>工作目录</td><td>指定容器内部的工作目录 如果没有创建则自动创建 如果指定/ 使用的是绝对地址 如果不是/开头那么是在上一条workdir的路径的相对路径</td></tr><tr><td>USER</td><td>指定执行用户</td><td>指定build或者启动的时候 用户 在RUN CMD ENTRYPONT执行的时候的用户</td></tr><tr><td>HEALTHCHECK</td><td>健康检查</td><td>指定监测当前容器的健康监测的命令 基本上没用 因为很多时候 应用本身有健康监测机制</td></tr><tr><td>ONBUILD</td><td>触发器</td><td>当存在ONBUILD关键字的镜像作为基础镜像的时候 当执行FROM完成之后 会执行 ONBUILD的命令 但是不影响当前镜像 用处也不怎么大</td></tr><tr><td>STOPSIGNAL</td><td>发送信号量到宿主机</td><td>该STOPSIGNAL指令设置将发送到容器的系统调用信号以退出。</td></tr><tr><td>SHELL</td><td>指定执行脚本的shell</td><td>指定RUN CMD ENTRYPOINT 执行命令的时候 使用的shell</td></tr></tbody></table></figure><p>&nbsp;</p><h4><a name='header-n2857' class='md-header-anchor '></a>5.3.2 Centos</h4><p>自定义centos7镜像：</p><ol start='' ><li>默认登录路径为 /usr</li><li>可以使用vim</li></ol><p>实现步骤：</p><ol start='' ><li>定义父镜像：FROM centos:7</li><li>定义作者信息：MAINTAINER  seazean &lt; <a href='mailto:zhyzhyang@sina.com' target='_blank' class='url'>zhyzhyang@sina.com</a>&gt;</li><li>执行安装vim命令： RUN yum install -y vim</li><li>定义默认的工作目录：WORKDIR /usr</li><li>定义容器启动执行的命令：CMD /bin/bash</li><li>通过dockerfile构建镜像：docker bulid –f dockerfile文件路径 –t 镜像名称:版本</li></ol><p>&nbsp;</p><h4><a name='header-n2879' class='md-header-anchor '></a>5.3.3 Boot</h4><p>定义dockerfile，发布springboot项目：</p><p>实现步骤：</p><ol start='' ><li>定义父镜像：FROM java:8</li><li>定义作者信息：MAINTAINER seazean &lt; <a href='mailto:zhyzhyang@sina.com' target='_blank' class='url'>zhyzhyang@sina.com</a>&gt;</li><li>将jar包添加到容器： ADD springboot.jar app.jar</li><li>定义容器启动执行的命令：CMD java–jar app.jar</li><li>通过dockerfile构建镜像：docker bulid –f dockerfile文件路径 –t 镜像名称:版本</li></ol><p>&nbsp;</p><p>&nbsp;</p><hr /><p>&nbsp;</p><h2><a name='header-n2897' class='md-header-anchor '></a>6. 服务编排</h2><h3><a name='header-n2898' class='md-header-anchor '></a>6.1 基本介绍</h3><p>微服务架构的应用系统中一般包含若干个微服务，每个微服务一般都会部署多个实例，如果每个微服务都要手动启停，维护的工作量会很大。</p><ul><li>从Dockerfile build image 或者去dockerhub拉取image；</li><li>创建多个container，管理这些container（启动停止删除）</li></ul><p><strong>服务编排</strong>：按照一定的业务规则批量管理容器</p><p>Docker Compose是一个编排多容器分布式部署的工具，提供命令集管理容器化应用的完整开发周期，包括服务构建，启动和停止。使用步骤：</p><ol start='' ><li>利用 Dockerfile 定义运行环境镜像</li><li>使用 docker-compose.yml 定义组成应用的各服务</li><li>运行 docker-compose up 启动应用</li></ol><p><img src='https://img-blog.csdnimg.cn/66906b3397e041f6b56a3741ed75cf12.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><p>&nbsp;</p><hr /><p>&nbsp;</p><h3><a name='header-n2918' class='md-header-anchor '></a>6.2 功能实现</h3><p>使用docker compose编排nginx+springboot项目</p><ol start='' ><li><p>安装Docker Compose</p></li><li><p>创建docker-compose目录</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sh" contenteditable="false" cid="n2925" mdtype="fences">mkdir ~/docker-compose
cd ~/docker-compose
</pre></li><li><p>编写 docker-compose.yml 文件</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sh" contenteditable="false" cid="n2928" mdtype="fences" style="break-inside: unset;">version: '3'
services:
  nginx:
   image: nginx
   ports:
    - 80:80
   links:
    - app
   volumes:
    - ./nginx/conf.d:/etc/nginx/conf.d
  app:
    image: app
    expose:
      - "8080"
</pre></li><li><p>创建./nginx/conf.d目录</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sh" contenteditable="false" cid="n2931" mdtype="fences">mkdir -p ./nginx/conf.d
</pre></li><li><p>在./nginx/conf.d目录下编写***.conf文件</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sh" contenteditable="false" cid="n2934" mdtype="fences">server {
    listen 80;
    access_log off;

    location / {
        proxy_pass http://app:8080;
    }
}
</pre></li><li><p>在~/docker-compose 目录下使用docker-compose启动容器</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sh" contenteditable="false" cid="n2937" mdtype="fences">docker-compose up
</pre></li><li><p>测试访问</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sh" contenteditable="false" cid="n2940" mdtype="fences">http://192.168.0.137/hello
</pre><p>&nbsp;</p></li></ol><hr /><p>&nbsp;</p><p>&nbsp;</p><h2><a name='header-n2945' class='md-header-anchor '></a>7. 私有仓库</h2><p>Docker官方的Docker hub（<a href='https://hub.docker.com' target='_blank' class='url'>https://hub.docker.com</a>）是一个用于管理公共镜像的仓库，我们可以从上面拉取镜像 到本地，也可以把我们自己的镜像推送上去。但是当服务器无法访问互联网，或者不希望将自己的镜像放到公网当中，那么我们就需要搭建自己的私有仓库来存储和管理自己的镜像</p><ul><li><p>私有仓库搭建</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sh" contenteditable="false" cid="n2950" mdtype="fences"># 1、拉取私有仓库镜像 
docker pull registry
# 2、启动私有仓库容器 
docker run -id --name=registry -p 5000:5000 registry
# 3、输入地址http://私有仓库服务器ip:5000/v2/_catalog，显示{"repositories":[]} 
# 4、修改daemon.json   
vim /etc/docker/daemon.json    
# 在上述文件中添加一个key，保存退出。此步用于让 docker 信任私有仓库地址；注意将私有仓库服务器ip修改为自己私有仓库服务器真实ip 
{"insecure-registries":["192.168.0.137:5000"]} 
# 5、重启docker 服务 
systemctl restart docker
docker start registry
</pre></li><li><p>将镜像上传至私有仓库</p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sh" contenteditable="false" cid="n2953" mdtype="fences"># 1、标记镜像为私有仓库的镜像     
docker tag centos:7 私有仓库服务器IP:5000/centos:7
 
# 2、上传标记的镜像     
docker push 私有仓库服务器IP:5000/centos:7
</pre></li><li><p>从私有仓库拉取镜像 </p><pre spellcheck="false" class="md-fences mock-cm md-end-block" lang="sh" contenteditable="false" cid="n2956" mdtype="fences">#拉取镜像 
docker pull 私有仓库服务器ip:5000/centos:7
</pre><p>&nbsp;</p></li></ul><hr /><p>&nbsp;</p><h2><a name='header-n2960' class='md-header-anchor '></a>8. 虚拟机</h2><p>容器：</p><ul><li>容器是将软件打包成标准化单元，以用于开发、交付和部署</li><li>容器镜像是轻量的、可执行的独立软件包 ，包含软件运行所需的所有内容：代码、运行时环境、系统工具、系统库和设置</li><li>容器化软件在任何环境中都能够始终如一地运行。</li><li>容器赋予了软件独立性，使其免受外在环境差异的影响，从而有助于减少团队间在相同基础设施上运行不同软件时的冲突</li></ul><p>容器和虚拟机对比：</p><ul><li><p>相同：容器和虚拟机具有相似的资源隔离和分配优势</p></li><li><p>不同：</p><ul><li>容器虚拟化的是操作系统，虚拟机虚拟化的是硬件。</li><li>传统虚拟机可以运行不同的操作系统，容器只能运行同一类型操作系统</li></ul><p><img src='https://img-blog.csdnimg.cn/53961534d10b4f77b342c78f9de411e3.png' alt='在这里插入图片描述' referrerPolicy='no-referrer' /></p><figure><table><thead><tr><th>特性</th><th>容器</th><th>虚拟机</th></tr></thead><tbody><tr><td>启动</td><td>秒级</td><td>分钟</td></tr><tr><td>硬盘使用</td><td>一般为MB</td><td>一般为GB</td></tr><tr><td>性能</td><td>接近原生</td><td>弱于原生</td></tr><tr><td>系统支持量</td><td>单机支持上千个容器</td><td>一般几十个</td></tr></tbody></table></figure><p>&nbsp;</p></li></ul><h1><a name='header-n3005' class='md-header-anchor '></a>四、后会有期</h1><blockquote><p>路漫漫其修远兮，吾将上下而求索</p><p>纸上得来终觉浅，绝知此事要躬行</p></blockquote></div>
</body>
</html>